{"./":{"url":"./","title":"前言","keywords":"","body":"Introduction 这是使用gitbook构建的静态网站 构建过程 安装 安装node cnpm install -g gitbook-cli 输入 gitbook --version，等待GitBook安装完成。再次输入即可查看到版本信息，安装成功 建站 创建一个文件夹，相当于本网站的根目录，输入gitbook init命令。 gitbook serve，进入 http://localhost:4000 就可以看见网站了。首页即是README.md文件内容。按Ctrl + C 退出本地服务。 插件安装 在本书根目录新建book.json文件，并在\"plugins\": [\"splitter\"]里写入插件名。然后执行命令gitbook install ./安装插件。 参考资料 我现在的book.json配置参考 book.json配置参考 本文详细讲解了 Gitbook 生成电子书的完整过程，内容包括：安装、命令、配置、文档结构、生成电子书、部署 雪之梦技术驿站 gitbook 入门教程之使用 gitbook-cli 开发电子书 Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-04-12 17:34:20 "},"leetcode/":{"url":"leetcode/","title":"leetcode","keywords":"","body":"leetcode 记录leetcode刷题 Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-04-02 11:46:43 "},"leetcode/2020_04月/":{"url":"leetcode/2020_04月/","title":"4月每题","keywords":"","body":"4月每题 2020年3、4月leetcode，组织每日一题活动。刚好今天捣鼓GitBook，遂记录四月刷题经验。 Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-04-02 11:48:27 "},"leetcode/2020_04月/4.2.html":{"url":"leetcode/2020_04月/4.2.html","title":"4.2 生命游戏","keywords":"","body":"4.2 生命游戏 题目描述 根据百度百科，生命游戏，简称为生命，是英国数学家约翰·何顿·康威在 1970 年发明的细胞自动机。 给定一个包含m×n个格子的面板，每一个格子都可以看成是一个细胞。每个细胞都具有一个初始状态：1 即为活细胞（live），或 0 即为死细胞（dead）。每个细胞与其八个相邻位置（水平，垂直，对角线）的细胞都遵循以下四条生存定律： 如果活细胞周围八个位置的活细胞数少于两个，则该位置活细胞死亡； 如果活细胞周围八个位置有两个或三个活细胞，则该位置活细胞仍然存活； 如果活细胞周围八个位置有超过三个活细胞，则该位置活细胞死亡； 如果死细胞周围正好有三个活细胞，则该位置死细胞复活； 根据当前状态，写一个函数来计算面板上所有细胞的下一个（一次更新后的）状态。下一个状态是通过将上述规则同时应用于当前状态下的每个细胞所形成的，其中细胞的出生和死亡是同时发生的。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/game-of-life 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 示例： 输入： [ [0,1,0], [0,0,1], [1,1,1], [0,0,0] ] 输出： [ [0,0,0], [1,0,1], [0,1,1], [0,1,0] ] 题解1 题目要求只能在原数组上进行修改，函数不返回结果。难点在于修改原数组会改变状态，从而影响之后的细胞状态判断。 整体思路： 对原数组board拷贝一份，记作grid，将grid作为初始状态数组进行遍历； 然后对满足条件的，修改对应位置的原数组board值。 python3代码如下： import copy class Solution: def gameOfLife(self, board: List[List[int]]) -> None: \"\"\" Do not return anything, modify board in-place instead. \"\"\" grid = copy.deepcopy(board) # 进行深拷贝 board值的变化不会影响grid direc = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)] for i in range(len(grid)): for j in range(len(grid[0])): cnt = 0 for a, b in direc: r = i+a; c = j+b if -13: board[i][j] = 0 elif cnt==3: board[i][j] = 1 注意事项： 函数传入的数组是一个引用，若在函数中对其改变，就可以影响到函数外的变量。而且要import copy使用深拷贝copy.deepcopy()， 或者使用grid = [[board[i][j] for j in range(len(board[0]))] for i in range(len(board))]。 这种方法直接模拟现实，但当数组过大，复制时消耗内存过大。时间复杂度$O(nm)$，空间复杂度$O(nm)$ 题解2 不进行数组复制。因为每个细胞状态只用改变一次，且和周围八个细胞的初始状态有关。所以可以就在原数组上进行改变，但是要保留其初始状态的信息。 注意题目中状态变化有两种：原本死 -> 活；原本活 -> 死。 于是可以增加两个状态标志，-1表示由死->活，2表示由活->死。这样就可以在不复制的情况下，既改变起始状态，又可以知道细胞的原本状态，互不干扰。最后再遍历一次数组，将-1替换为1，2替换为0。 python3代码如下： class Solution: def gameOfLife(self, board: List[List[int]]) -> None: \"\"\" Do not return anything, modify board in-place instead. \"\"\" direc = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)] for i in range(len(board)): for j in range(len(board[0])): cnt = 0 for a, b in direc: r = i+a; c = j+b # board[r][l] == 1 or board[i][j] == 2说明细胞初始状态为'活' if -10: cnt += 1 if board[i][j]>0: if cnt3: board[i][j] = 2 elif cnt==3: board[i][j] = -1 for i in range(len(board)): for j in range(len(board[0])): if board[i][j] == -1: board[i][j] = 1 elif board[i][j] == 2: board[i][j] = 0 时间复杂度$O(nm)$，空间复杂度$O(1)$ 有趣的解法 看leetcode题解，有一些大佬的思路很清奇！ 对题解2的小改进 使用位运算，二进制下末位表示原始状态(1表示活，0表示死)，第二位表示下一状态(1表示活，0表示死)。 则统计board[i][j]周围活细胞的个数条件为board[r][c]&1==1， 改变状态通过位运算，活->活：board[i][j] |= 2；死->活：board[i][j] |= 2；活->死和死->死不做操作，因为1和0的二进制为01、00，第二位都是0表示下一状态为‘死’。 最后遍历数组一次，通过移位运算>>，右移1位即可。 卷积 类似图像处理中卷积操作，卷积模板为 1, 1, 1 1, 0, 1 1, 1, 1 要复制数组，并且在周围补0方便卷积。使用numpy操作。 Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-04-02 14:22:42 "},"leetcode/2020_04月/4.3.html":{"url":"leetcode/2020_04月/4.3.html","title":"4.3 T8字符串转换整数(atoi)","keywords":"","body":"4.3 T8字符串转换整数(atoi) 题目描述 请你来实现一个 atoi 函数，使其能将字符串转换成整数。 首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。接下来的转化规则如下： 如果第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字字符组合起来，形成一个有符号整数。 假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成一个整数。 该字符串在有效的整数部分之后也可能会存在多余的字符，那么这些字符可以被忽略，它们对函数不应该造成影响。 注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换，即无法进行有效转换。 在任何情况下，若函数不能进行有效的转换时，请返回 0 。 提示： 本题中的空白字符只包括空格字符' ' 。 假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−2^31, 2^31 − 1]。如果数值超过这个范围，请返回INT_MAX (2^31 − 1) 或 INT_MIN (−2^31) 。 示例： 输入: \"42\" 输出: 42 输入: \" -42\" 输出: -42 输入: \"4193 with words\" 输出: 4193 输入: \"words and 987\" 输出: 0 输入: \"-91283472332\" 输出: -2147483648 解释: 数字 \"-91283472332\" 超过 32 位有符号整数范围，因此返回 INT_MIN (−231) 。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/string-to-integer-atoi 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解1 疯狂的条件判断。 去除字符串左边的空格 判断符号 选择连续数字变为整数，并且判断是否溢出 循环里面还要判断 当访问到字母时，要退出循环 当已经访问到数字或符号后，再访问到空格要退出循环 当数溢出时返回对应32位有符号整数边界 很麻烦。注意对于python3而言没有整数溢出这个概念，因为python3是通过一段段字符串存储数组(大概意思，不是很确定)。 题解2 对题解1进行一定的修改。使用确定有限状态机，减少判断。 转换成表： 状态 ' ' +/- number other start start signed in_number end signed end end in_number end in_number end end in_number end end end end end end 题解3 正则表达式匹配 # python3 import re class Solution: def myAtoi(self, str: str) -> int: res = re.findall(r'^[+-]?\\d+', str.lstrip()) if res: a = int(res[0]) return max(a, -2**31) if a Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-04-12 17:04:40 "},"leetcode/2020_04月/4.4.html":{"url":"leetcode/2020_04月/4.4.html","title":"4.4 T42接雨水","keywords":"","body":"4.4 T42接雨水 题目描述 给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。 示例: 输入: [0,1,0,2,1,0,1,3,2,1,2,1] 输出: 6 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/trapping-rain-water 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 使用height数组存储柱子的高度。 题解1 使用动态规划，dp[i]存储到第i个(i从0开始)柱子可以存多少水。动态规划不熟练，写的很麻烦。 自底向上，根据初始状态推导出最终状态。 则初始状态dp[0]=0;dp[1]=0 状态转移: if height[i] 具体python3代码： class Solution: def trap(self, height: [int]) -> int: n = len(height) if n==0: return 0 dp = [0]*n for i in range(1, n): if height[i]-1 and height[j]up: dp[i] += (height[j]-up)*(i-j-1) up = height[j] j -= 1 if j>-1: dp[i] += (height[i]-up)*(i-j-1) return dp[-1] 时间复杂度接近$O(n^2)$，空间复杂度$O(n)$。不大行。执行用时56ms 题解2 暴力法，对每一个柱子算出它能盛多少水。 基本思路：从左到右遍历一次数组 算出左边柱子最大高度(包含自己) max_left 算出右边柱子最大高度(包含自己) max_right 则该柱子能盛水 min(max_left, max_right)-height[i] class Solution: def trap(self, height): water = 0 for i in range(1, len(height)-1): max_left = max(height[:i+1]) max_right = max(height[i:]) water += min(max_left, max_right)-height[i] return water 时间复杂度$O(n^2)$，空间复杂度$O(1)$。经提交发现执行的非常慢2368ms。可能和数组大量复制有关。 改进：使用两个数组存储$max_left_i$和$max_right_i$，就不用每次都去遍历求左右最大值。 题解3 使用栈。当访问柱子高度小于栈顶柱子高度就入栈；当高度大于栈顶柱子高度(说明中间有空隙可以盛水)，就退栈并加水。主要思想和题解1的DP类似，栈这个更好。 遍历柱子高度数组下标cur 若栈不空 或 height[cur]大于栈顶存储柱子高度 退栈top = stack.pop() 如果栈为空，左侧已经没有比height[top]更高的柱子，无法盛水，退出循环。 获取加水的高度 min(height[stack[-1]], height[cur]) - height[top] 获取加水宽度 cur-stack[-1]-1 将cur入栈，并且自加1 import collections class Solution: def trap(self, height): stack = collections.deque() cur = 0 water = 0 while curheight[stack[-1]]: top = stack.pop() if stack: water += (min(height[stack[-1]], height[cur]) - height[top])*(cur-stack[-1]-1) stack.append(cur) cur += 1 return water 时间复杂度$O(n)$，空间复杂度$O(n)$。执行时间40ms，击败95%python3。 Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-04-04 14:28:43 "},"leetcode/2020_04月/4.5.html":{"url":"leetcode/2020_04月/4.5.html","title":"4.5 T460FLU缓存","keywords":"","body":"4.5 T460FLU缓存 题目描述 请你为 最不经常使用（LFU）缓存算法设计并实现数据结构。它应该支持以下操作：get 和 put。 get(key) - 如果键存在于缓存中，则获取键的值（总是正数），否则返回 -1。 put(key, value) - 如果键不存在，请设置或插入值。当缓存达到其容量时，则应该在插入新项之前，使最不经常使用的项无效。在此问题中，当存在平局（即两个或更多个键具有相同使用频率）时，应该去除 最近 最少使用的键。 「项的使用次数」就是自插入该项以来对其调用 get 和 put 函数的次数之和。使用次数会在对应项被移除后置为 0 。 进阶： 你是否可以在 O(1) 时间复杂度内执行两项操作？ 示例： LFUCache cache = new LFUCache( 2 /* capacity (缓存容量) */ ); cache.put(1, 1); cache.put(2, 2); cache.get(1); // 返回 1 cache.put(3, 3); // 去除 key 2 cache.get(2); // 返回 -1 (未找到key 2) cache.get(3); // 返回 3 cache.put(4, 4); // 去除 key 1 cache.get(1); // 返回 -1 (未找到 key 1) cache.get(3); // 返回 3 cache.get(4); // 返回 4 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/lfu-cache 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解1 题目要求简单说就是实现两个功能，添加put()，查找get()。 难点： put()时，若容器已满，则要弹出使用频率最低中的最先被使用的值。 get()时，若容器中存在，则在返回其值的同时，对应的使用频率要+1。 如果单纯的用hash表存储键-值，键-频率，那么每次弹出元素时都要查找最不常用的键值对，非常耗时。 这里新建一个节点Node类，存储键对应的各种值，get()操作获取对应node对象的值，put()操作添加node对象新节点。 Node类有属性pre，key，value，fre，next。 再建立两个表和一个存储最小频率的变量 频率表fre_table，键为频率，值为链表。 键值表key_table，键为key，值为node。 存储最小频率。 其中频率表值为一个双向链表，返回head和tail的node节点。 每次新插入节点在头部插入，弹出节点通过tail.pre获取弹出。大致结构如图： # OK # 基本思路： # 建立一个频率表fre_table，键为频率，值为一个双向链表； # 建立一个键值对表key_table，键为值，值为Node节点 # get(key): # key在key_table中，则对应node.fre+=1，并且修改其在fre_table中的位置。最后返回node.value # put(key, value): # key在key_table中，增加其频率，并更新其值和在fre_table中的位置 # 若不在key_table中，且len(key_table) int: if key in self.key_table: self.linked_insert(self.key_table[key]) return self.key_table[key].value return -1 def put(self, key: int, value: int) -> None: if self.capacity>0: if key in self.key_table: self.linked_insert(self.key_table[key]) self.key_table[key].value = value else: if len(self.key_table)==self.capacity: head, _ = self.fre_table[self.min_fre] popkey = self.linked_delete(head.next) self.key_table.pop(popkey) if len(self.key_table) Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-04-06 16:17:51 "},"leetcode/2020_04月/4.6.html":{"url":"leetcode/2020_04月/4.6.html","title":"4.6 T72编辑距离","keywords":"","body":"4.6 T72编辑距离 题目描述 给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。 你可以对一个单词进行如下三种操作： 插入一个字符 删除一个字符 替换一个字符 示例 1： 输入：word1 = \"horse\", word2 = \"ros\" 输出：3 解释： horse -> rorse (将 'h' 替换为 'r') rorse -> rose (删除 'r') rose -> ros (删除 'e') 示例 2： 输入：word1 = \"intention\", word2 = \"execution\" 输出：5 解释： intention -> inention (删除 't') inention -> enention (将 'i' 替换为 'e') enention -> exention (将 'n' 替换为 'x') exention -> exection (将 'n' 替换为 'c') exection -> execution (插入 'u') 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/edit-distance 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解 使用动态规划，新建一个dp二维数组，其中dp[i][j]存储word1前i个字符串转化为word2前j个字符串的最少操作次数。 记m = len(word1); n = len(word2)，则dp数组是m+1行，n+1列。 则初始状态为： dp[i][0] = i for i in {0, 1, ..., m} dp[0][j] = j for j in {0, 1, ..., n} 再考虑状态转移 因为对word1字符串只有三种操作，增删改。 增：word1考虑字符个数+1， 对应状态转移 dp[i-1][j] -> dp[i][j] 则dp[i][j] 。 因为先对word1前i-1个字符进行dp[i-1][j]次操作得到word2前j个字符，再删掉word1的第i个字符。 删：word1考虑字符个数-1，等价于word2考虑字符数+1 对应状态转移 dp[i][j-1] -> dp[i][j] 同理：dp[i][j] 改：word1和word2考虑字符串个数没变 对应状态转移dp[i-1][j-1] -> dp[i][j], 则：dp[i][j] = dp[i-1][j-1]当word1第i个字符等于word2第j个字符时； 否则dp[i][j] = dp[i-1][j-1] + 1 于是可以写出代码(python3) class Solution: def minDistance(self, word1: str, word2: str) -> int: m, n = len(word1), len(word2) if n==0 or m==0: return m|n dp = [[0]*(n+1) for i in range(m+1)] # 初始化 for i in range(m+1): dp[i][0] = i for j in range(n+1): dp[0][j] = j # 状态转移 for i in range(1, m+1): for j in range(1, n+1): left = dp[i][j-1]+1 up = dp[i-1][j]+1 lu = dp[i-1][j-1] if word1[i-1]!=word2[j-1]: lu += 1 dp[i][j] = min(left, up, lu) return dp[-1][-1] Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-04-06 15:17:23 "},"leetcode/2020_04月/4.7.html":{"url":"leetcode/2020_04月/4.7.html","title":"4.7 旋转矩阵","keywords":"","body":"4.7 旋转矩阵 题目描述 给你一幅由 N × N 矩阵表示的图像，其中每个像素的大小为 4 字节。请你设计一种算法，将图像旋转 90 度。 不占用额外内存空间能否做到？ 示例 1: 给定 matrix = [ [1,2,3], [4,5,6], [7,8,9] ], 原地旋转输入矩阵，使其变为: [ [7,4,1], [8,5,2], [9,6,3] ] 示例 2: 给定 matrix = [ [ 5, 1, 9,11], [ 2, 4, 8,10], [13, 3, 6, 7], [15,14,12,16] ], 原地旋转输入矩阵，使其变为: [ [15,13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7,10,11] ] 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/rotate-matrix-lcci 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解1 一看到这个，第一反应是矩阵转置，只不过有一点不同。 本文行列都以0开始计数，因为题目是方阵，旋转后行列不变，所以可以在其自身上进行变化。记n = len(matrix) 分析： matrix[i][j] -> matrix[j][n-1-i]原矩阵第i行第j列的值移动到第j行第(n-1-i)列。 因为又要同时修改原矩阵第j行第(n-1-i)列的值，所以如果直接进行(i,j)和(j, n-1-i)对应值的交换，会(j, n-1-i)的值产生影响。(这里为了方便，使用坐标(i, j)指定matrix[i][j]) 又观察发现，本题要求顺时针旋转90度。但是其转置和目标状态是关于最中间列对称的。所以 可以先对方阵进行转置将(i, j) -> (j, i) 再进行对称交换 (j, i) -> (j, n-1-i) 并且两次操作，都可以直接对对应位置值进行交换，不会对其他值交换产生影响。easy class Solution: def rotate(self, matrix: List[List[int]]) -> None: \"\"\" Do not return anything, modify matrix in-place instead. \"\"\" n = len(matrix) for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] for i in range(n): for j in range(n//2): matrix[i][j], matrix[i][n-1-j] = matrix[i][n-1-j], matrix[i][j] 遍历两次方阵，时间复杂度$O(n^2)$，空间复杂度$O(1)$。 题解2 先新建一个 nxn 目标状态的方阵，然后按照旋转规则(i, j) -> (j, n-1-i)，将res[j][n-1-i] = matrix[i][j]，代码如下： class Solution: def rotate(self, matrix: List[List[int]]) -> None: n = len(matrix) res = [[0]*n for _ in range(n)] for i in range(n): for j in range(n): res[j][n-1-i] = matrix[i][j] # 注意这里是[:]，否则函数外的matrix不会被改变 matrix[:] = res 注意：最后matrix[:] = res。 通过python的数据存储规则加以理解。 题解3 对题解1的改进，按照旋转原理(row, col) -> (col, n-1-row) (i, j) -> (j, n-1-i) (j, n-1-i) -> (n-1-i, n-1-j) (n-1-i, n-1-j) -> (n-1-j, i) (n-1-j, i) -> (i, j) 这四个位置的值形成一组进行替换 class Solution: def rotate(self, matrix: List[List[int]]) -> None: n = len(matrix) for i in range(n//2): for j in range((n+1)//2): matrix[j][n-1-i], matrix[n-1-i][n-1-j], matrix[n-1-j][i], matrix[i][j] = \\ matrix[i][j], matrix[j][n-1-i], matrix[n-1-i][n-1-j], matrix[n-1-j][i] 时间复杂度$O(n^2)$，空间复杂度$O(1)$。 Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-04-07 13:56:59 "},"leetcode/2020_04月/4.8.html":{"url":"leetcode/2020_04月/4.8.html","title":"4.8 面试题13.机器人的运动范围","keywords":"","body":"4.8 面试题13.机器人的运动范围 题目描述 地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？ 示例 1： 输入：m = 2, n = 3, k = 1 输出：3 示例 2： 输入：m = 3, n = 1, k = 0 输出：1 提示： 1 0 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解1 简单分析，就是一个单点的BFS或DFS，搜索时加个条件(坐标各位数和小于等于k才可以被访问)。 注意：机器人不能飞，也就是说是单点源搜索。 代码就很好写了，python3如下 import collections class Solution: def movingCount(self, m: int, n: int, k: int) -> int: visit = [[0]*n for _ in range(m)] stack = collections.deque() direc = [(0, 1), (1, 0), (0, -1), (-1, 0)] def get(a): su = 0 while a>0: su += a%10 a = a//10 return su stack.append((0, 0)) visit[0][0] = -1 res = 0 while stack: i, j = stack.pop() res += 1 for i_, j_ in direc: r, l = i+i_, j+j_ if rm-1 or ln-1: continue if visit[r][l] == -1: continue if get(r) + get(l)>k: continue stack.append((r, l)) visit[r][l] = -1 return res 这里使用collections.deque()作为栈，因为python默认List数据结构设计结构类似数组，移除元素时间复杂度$O(n)$，频繁操作很慢。而deque()是双端队列，只允许在头尾添加删除，类似链表，适合当栈。 类似BFS也一样可以写。 题解2 反向思考，如果要访问坐标(i, j)，只要满足： i和j的各位数和不大于k， 并且可以访问到(i-1, j)或(i, j-1)。 def digitsum(n): ans = 0 while n: ans += n % 10 n //= 10 return ans class Solution: def movingCount(self, m: int, n: int, k: int) -> int: vis = set([(0, 0)]) for i in range(m): for j in range(n): if ((i - 1, j) in vis or (i, j - 1) in vis) and digitsum(i) + digitsum(j) Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-04-08 16:33:55 "},"leetcode/2020_04月/4.9.html":{"url":"leetcode/2020_04月/4.9.html","title":"4.9 T22括号生成","keywords":"","body":"4.9 T22括号生成 题目描述 数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。 示例： 输入：n = 3 输出：[ \"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\" ] 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/generate-parentheses 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 分析 类似对一棵树进行搜索，树节点为括号字符串。可以使用BFS和DFS。使用DFS更方便，因为DFS时函数递归直接使用系统栈，无需人工编写栈。 题解1 模拟括号生成，每次在之前的字符串上添加'('或')'，若合法就加入结果列表。 class Solution: def generateParenthesis(self, n: int) -> List[str]: def isvalid(s): left = 0 for i in s: if left 时间复杂度$O(2^{2n})$，空间复杂度$O(n)$ 题解2 对题解1进行改进，只有当字符串合法时，才添加括号，减少递归。 class Solution: def generateParenthesis(self, n: int) -> List[str]: ans = [] def backtrack(S, left, right): if len(S) == 2 * n: ans.append(''.join(S)) return if left 题解3 动态规划，使用数组dp[i]存储i对括号合法的结果。最后返回dp[n]。 初始状态： dp[0] = [''] 状态转移： dp[i] = '(' + dp[j] + ')' + dp[i-j-1] 因为dp[i] i对括号组成的合法字符串，可以写成(a)b，其中a，b都是合法括号字符串。 需证明由(a)b生成的字符串括号，刚好覆盖所有结果，并且不会出现重复。 class Solution: def generateParenthesis(self, n: int) -> List[str]: if n Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-04-09 11:59:47 "},"leetcode/2020_04月/4.10.html":{"url":"leetcode/2020_04月/4.10.html","title":"4.10 T151翻转字符串里的单词","keywords":"","body":"4.10 T151翻转字符串里的单词 题目 给定一个字符串，逐个翻转字符串中的每个单词。 示例 1： 输入: \"the sky is blue\" 输出: \"blue is sky the\" 示例 2： 输入: \" hello world! \" 输出: \"world! hello\" 解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。 示例 3： 输入: \"a good example\" 输出: \"example good a\" 解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。 说明： 无空格字符构成一个单词。 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/reverse-words-in-a-string 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解1 直接使用现有工具完成，例如： python字符串的split()以及数组连接''.join() 正则匹配 class Solution: def reverseWords(self, s: str) -> str: return \" \".join((s.split())[::-1]) 或者使用正则匹配，\\s表示任意空字符，\\S表示任意非空字符。 import re class Solution: def reverseWords(self, s: str) -> str: li = re.findall(\"\\s?(\\S+)\\s?\", s) return ' '.join(li[::-1]) 题解2 依次遍历字符串，找到单词并插入队列头部，然后再使用空格连接。 Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-04-10 09:38:04 "},"leetcode/2020_04月/4.11.html":{"url":"leetcode/2020_04月/4.11.html","title":"4.11 T887鸡蛋掉落","keywords":"","body":"4.11 T887鸡蛋掉落 题目 你将获得 K 个鸡蛋，并可以使用一栋从 1 到 N 共有 N 层楼的建筑。 每个蛋的功能都是一样的，如果一个蛋碎了，你就不能再把它掉下去。 你知道存在楼层 F ，满足 0 你的目标是确切地知道 F 的值是多少。 无论 F 的初始值如何，你确定 F 的值的最小移动次数是多少？ 示例 1： 输入：K = 1, N = 2 输出：2 解释： 鸡蛋从 1 楼掉落。如果它碎了，我们肯定知道 F = 0 。 否则，鸡蛋从 2 楼掉落。如果它碎了，我们肯定知道 F = 1 。 如果它没碎，那么我们肯定知道 F = 2 。 因此，在最坏的情况下我们需要移动 2 次以确定 F 是多少。 示例 2： 输入：K = 2, N = 6 输出：3 示例 3： 输入：K = 3, N = 14 输出：4 提示： 1 1 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/super-egg-drop 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 分析 题目意思是无论F的初始值如何，你确定F的值的最小移动次数是多少？ 我们已知，通过不同的策略，针对不同的F值，最后扔鸡蛋的次数都不同。 设策略集合为$A$，F取值集合为$B$，$X_{ab}$表示策略$a$在F等于$b$时的扔鸡蛋次数，其中$a \\in A$，$b \\in B$。 则我们的目标，对于一个固定F值为$b0 \\in B$，找到所有不同策略所需的次数最大值$Y{b0} = max{a \\in A}(X{ab_0})$，即最坏策略要多少次测出F。 再对每一个F值$b \\in B$，取所有的$Y{b}$的最小值即为结果$res = min{b \\in B}Y{b}$。 题解1 基本动态规划。定义状态dp(k, n)表示有k个鸡蛋，n层楼，至少需要扔鸡蛋的次数(即结果)。 采用由顶向下的备忘录式动态规划。对于k个鸡蛋n层楼，假设当前选择第$i$层扔出，$i \\in {1,2,\\dots,n}$。有两种情况： 第$i$层扔出，鸡蛋碎，说明F 第$i$层扔出，鸡蛋没碎，说明F >= $i$。下一步测试楼上需要dp(k, n-i)次 对于本次策略(从第i层扔出鸡蛋)，我们得到最坏情况下扔鸡蛋次数： tmpi=max(dp(k−1,i−1),dp(k,n−i))+1,i∈1,2,...,n tmp_i = max( dp(k-1, i-1), dp(k, n-i) ) + 1, \\quad i \\in {1,2,...,n} tmp​i​​=max(dp(k−1,i−1),dp(k,n−i))+1,i∈1,2,...,n $tmp_i$表示对于k个鸡蛋n层楼，第一次从第i层扔出鸡蛋，测出F需要的最多次数。 然后对于当前情况，最终结果$dp(k, n)$，就应该为对每一个$i \\in {1,2,...,n}$ 求得一个$tmp_i$，再取所有$tmp_i$的最小值。即： res=min(tmpi)for all i∈1,2,...,n res = min(tmp_i) \\quad for \\ all \\ i \\in {1,2,...,n} res=min(tmp​i​​)for all i∈1,2,...,n 转换一下表述即： 初始状态： k=1时，dp(1, n)返回n n=0时，dp(k, 0)返回0 状态转移 dp(k, n) = min( max( dp(k-1, i-1), dp(k, n-i) ) ) + 1 , for i in range(1, n+1) python3代码如下： class Solution: def superEggDrop(self, K: int, N: int) -> int: # 备忘录 meno = {} def dp(k, n): # k个鸡蛋n层楼，最少扔鸡蛋的次数 if k==1: return n if n==0: return 0 if (k, n) in meno: return meno[(k, n)] res = float('INF') for i in range(1, n+1): res = min( res, max( dp(k, n-i), # 在第i层扔鸡蛋，没碎。测试楼上n-i层 dp(k-1, i-1) # 在第i层扔鸡蛋，碎了。测试楼下i-1层 ) + 1 # 取两种情况的最坏值，再加扔第i层的一次 ) # 遍历当前的每个楼层，去最好的一个 meno[(k, n)] = res return res return dp(K, N) 时间复杂度$O(KN^2)$，空间复杂度$O(K N)$。子问题个数即状态个数共$K * N$个，每个状态里经过一次遍历$N$次。 题解2 对题解1进行改进，因为dp(k, n)随着n增大递增， 所以对于固定的k，n，随着i的增大，dp(k, n-i)递减，dp(k-1, i-1)递增。 且i==1时，dp(k-1, i-1)=dp(k-1, 0)=0，所以dp(k-1, i-1)， 可以使用二分查找到dp(k, n) = min( max( dp(k-1, i-1), dp(k, n-i) ) ) class Solution: def superEggDrop(self, K: int, N: int) -> int: ''' 时间复杂度：O(K * N * logN) 空间复杂度：O(K * N) ''' meno = {} def dp(k, n): # k个鸡蛋n层楼，最少扔鸡蛋的次数 if k == 1: return n if n == 0: return 0 if (k, n) in meno: return meno[(k, n)] le, ri = 1, n res = float('INF') while le no_broken: res = min(res, broken + 1) ri = mid - 1 else: res = min(res, no_broken + 1) le = mid + 1 meno[(k, n)] = res return res return dp(K, N) 时间复杂度：$O(K N logN)$，空间复杂度：$O(K * N)$。因为把线性查找变为二分查找。 题解3 对方法二的改进，本方法参考leetcode题解 dp(k,n)=mini∈1,2,...,n(max(dp(k−1,i−1),dp(k,n−i))+1)dp(k, n) = min_{i \\in 1,2,...,n}( max( dp(k-1, i-1), dp(k, n-i) ) + 1 )dp(k,n)=min​i∈1,2,...,n​​(max(dp(k−1,i−1),dp(k,n−i))+1) $x = argmin_{x \\in 1,2,...,n}[ max( dp(k-1, x-1), dp(k, n-x) ) ]$ 基本思路：dp(k, n)关于n是递增的。则随着n递增，dp(k-1, i-1)和dp(k, n-i)的交点x逐渐变大， 所以固定k，递增n，x也递增。 只需一次遍历就可得到所有的dp(k, i)，其中i in {1,2...,n}，k固定。 class Solution: def superEggDrop(self, K: int, N: int) -> int: ''' 时间复杂度：O(K * N) 空间复杂度：O(N) ''' # Right now, dp[i] represents dp(1, i) dp = list(range(N + 1)) # 存储dp(k-1, i) i \\in {1,2...,N} dp2 = [0] * (N + 1) # 存储dp(k, i) i \\in {1,2...,N} for k in range(2, K + 1): # Now, we will develop dp2[i] = dp(k, i) x = 1 for n in range(1, N + 1): # Let's find dp2[n] = dp(k, n) # Increase our optimal x while we can make our answer better. # Notice max(dp[x-1], dp2[n-x]) > max(dp[x], dp2[n-x-1]) # is simply max(T1(x-1), T2(x-1)) > max(T1(x), T2(x)). while x = max(dp[x], dp2[n - x - 1]): x += 1 # 因为交点x解递增，所以在n循环内，x直接使用上次n-1的解作为初值递增即可，不用重置为1 # The final answer happens at this x. dp2[n] = 1 + max(dp[x - 1], dp2[n - x]) dp = dp2[:] return dp[-1] # 作者：LeetCode - Solution # 链接：https: // leetcode - cn.com / problems / super - egg - drop / solution / ji - dan - diao - luo - by - leetcode - solution / # 来源：力扣（LeetCode） # 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 题解4 全新方法，定义不同的状态 dp[k][m]表示k个鸡蛋，扔m次，至少可以测出多少层楼。 状态转移：dp[k][m] = dp[k-1][m-1] + 1 + dp[k][m-1] dp[k-1][m-1]--楼下 1--本层 dp[k][m-1]--楼上 def superEggDrop_4(self, K: int, N: int) -> int: ''' 时间复杂度：O(K * N) 空间复杂度：O(K * N) ''' dp = [[0]*(N+1) for _ in range(K+1)] # for i in range(1, N+1): # for j in range(1, K+1): # dp[j][i] = dp[j-1][i-1] + 1 + dp[j][i-1] # if dp[K][i] >= N: # return i m = 0 while dp[K][m] Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-04-12 15:33:45 "},"leetcode/2020_04月/4.12.html":{"url":"leetcode/2020_04月/4.12.html","title":"4.12 面试题16.03.交点","keywords":"","body":"4.12 面试题16.03.交点 题目 给定两条线段（表示为起点start = {X1, Y1}和终点end = {X2, Y2}），如果它们有交点，请计算其交点，没有交点则返回空值。 要求浮点型误差不超过10^-6。若有多个交点（线段重叠）则返回 X 值最小的点，X 坐标相同则返回 Y 值最小的点。 示例 1： 输入： line1 = {0, 0}, {1, 0} line2 = {1, 1}, {0, -1} 输出： {0.5, 0} 示例 2： 输入： line1 = {0, 0}, {3, 3} line2 = {1, 1}, {2, 2} 输出： {1, 1} 示例 3： 输入： line1 = {0, 0}, {1, 1} line2 = {1, 0}, {2, 1} 输出： {}，两条线段没有交点 提示： 坐标绝对值不会超过 2^7 输入的坐标均是有效的二维坐标 分析 算出两条直线的斜率k和截距b，若直线垂直于x轴，则k=INF。分情况讨论 有直线垂直于x轴，则将x轴交点坐标代入另一条直线，判断是否相交 斜率都存在，判断是否相交，然后用二分法计算交点坐标(也可以用公式先解出两个直线方程的交点解析解，再直接计算) 我最开始使用二分计算，代码写的惨不忍睹.....相当的垃圾 class Solution: def intersection(self, start1: List[int], end1: List[int], start2: List[int], end2: List[int]) -> List[float]: def get_kb(start, end): k, b = 0.0, 0.0 x1, y1 = start x2, y2 = end if x1==x2: k = INF return k, b k = (y1-y2)/(x1-x2) b = y1 - k*x1 return k, b def is_true(k, b, x): diff =k*x+b if diff>DIFF: return 1 elif diffdot2[0]: return dot2, dot1 if dot1[1]>dot2[1]: return dot2, dot1 return dot1, dot2 INF = float('INF') DIFF = 1e-7 s1, e1 = setdots(start1, end1) s2, e2 = setdots(start2, end2) k1, b1 = get_kb(s1, e1) k2, b2 = get_kb(s2, e2) if k1==INF and k2==INF: if s1[0]!=s2[0]: return [] else: a, b = s1[1], e1[1] if a>b: a, b = b, a c, d = s2[1], e2[1] if c>d: c, d = d, c if as2[0] else s2[0] right = e1[0] if e1[0]0: k = -k; b = -b if is_true(k, b, left) * is_true(k, b, right)>0: return [] res = [] while left=DIFF: right = x else: res = [x, k1*x+b1] break return res 下面是leetcode官方题解python的代码，是先用公式算出交点解析解，再直接计算。 class Solution: def intersection(self, start1: List[int], end1: List[int], start2: List[int], end2: List[int]) -> List[float]: # 判断 (xk, yk) 是否在「线段」(x1, y1)~(x2, y2) 上 # 这里的前提是 (xk, yk) 一定在「直线」(x1, y1)~(x2, y2) 上 def inside(x1, y1, x2, y2, xk, yk): # 若与 x 轴平行，只需要判断 x 的部分 # 若与 y 轴平行，只需要判断 y 的部分 # 若为普通线段，则都要判断 return (x1 == x2 or min(x1, x2) Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-04-12 15:20:17 "},"leetcode/2020_04月/4.13.html":{"url":"leetcode/2020_04月/4.13.html","title":"4.13 T355.设计推特","keywords":"","body":"4.13 T355.设计推特 题目 设计一个简化版的推特(Twitter)，可以让用户实现发送推文，关注/取消关注其他用户，能够看见关注人（包括自己）的最近十条推文。你的设计需要支持以下的几个功能： postTweet(userId, tweetId): 创建一条新的推文 getNewsFeed(userId): 检索最近的十条推文。每个推文都必须是由此用户关注的人或者是用户自己发出的。推文必须按照时间顺序由最近的开始排序。 follow(followerId, followeeId): 关注一个用户 unfollow(followerId, followeeId): 取消关注一个用户 示例: Twitter twitter = new Twitter(); // 用户1发送了一条新推文 (用户id = 1, 推文id = 5). twitter.postTweet(1, 5); // 用户1的获取推文应当返回一个列表，其中包含一个id为5的推文. twitter.getNewsFeed(1); // 用户1关注了用户2. twitter.follow(1, 2); // 用户2发送了一个新推文 (推文id = 6). twitter.postTweet(2, 6); // 用户1的获取推文应当返回一个列表，其中包含两个推文，id分别为 -> [6, 5]. // 推文id6应当在推文id5之前，因为它是在5之后发送的. twitter.getNewsFeed(1); // 用户1取消关注了用户2. twitter.unfollow(1, 2); // 用户1的获取推文应当返回一个列表，其中包含一个id为5的推文. // 因为用户1已经不再关注用户2. twitter.getNewsFeed(1); 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/design-twitter 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解1 建立Node类，存储文章信息，如文章id，文章发表时间。 建立两个hash表，其中一个用户表，键为用户id，值为文章Node节点(可构成单链表)； 另一个是关注表，键为用户id，值为列表(存储该用户关注的人的id)。 发送，对用户表的单链表表头插入新文章节点。 关注和取关，都是对关注表中的list添加或移除操作。 获取文章，对k个链表合并，取10篇最新的node节点的id 大方向不是很难，主要是细节问题，用来应对用户的各种(合理或不合理的)操作 以下列出一些遇到过的操作： 关注了自己---->对应合并链表时，对关注表中自己节点单独处理 用户关注了别人，但自己没有文章---->合并链表时，注意判断用户表自己对应的值是否非空 对没有发布文章的用户操作获取其文章 用户在发文章时，已经被其他人关注了 用户重复关注同一个人 .... 代码很乱，还有改进的空间...不过已经AC了，python3时间击败78.33%，内存击败100%....不想改 合并链表时的方法可以改进； 单链表存储可以只存储上限10个； 代码逻辑中对用户是否存在或重复做出了大量判断，因为python自带的dict，访问不存在的键时会报错； class Node: def __init__(self, val, time): self.val = val # 文章的id self.time = time # 文章发表的时间 self.next = None # 下一个节点，构成单链表 class Twitter: def __init__(self): \"\"\" Initialize your data structure here. \"\"\" self.usermeno = {} # {int: node} 用户hash表 self.follmeno = {} # {int: list} 关注hash表 self.maxCount = 10 # 返回值最大结果 self.time = 0 # 时间 def postTweet(self, userId: int, tweetId: int) -> None: \"\"\" Compose a new tweet. \"\"\" # 新建文章，并且时间加一 node = Node(tweetId, self.time) self.time += 1 # 当用户没发表过文章时，在用户表中新建键值对 # 并且在关注表中也初始化一下 if userId not in self.usermeno: self.usermeno[userId] = node # 如果该用户没发文章，但是被关注了，则该用户对于的关注表保持原样 if userId not in self.follmeno: self.follmeno[userId] = [] # 否则将最新文章node插入到表头 else: head = self.usermeno[userId] node.next = head self.usermeno[userId] = node def getNewsFeed(self, userId: int) -> [int]: \"\"\" Retrieve the 10 most recent tweet ids in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent. \"\"\" res = [] # 解决非法输入 if userId not in self.follmeno: return res if not self.follmeno[userId]: if userId not in self.usermeno: return res i = self.usermeno[userId] cnt = 0 while i and cnt nodeli[ind].time: ind = i return ind cnt = 0 ind = getnew(li) while cnt None: \"\"\" Follower follows a followee. If the operation is invalid, it should be a no-op. \"\"\" if followerId not in self.follmeno: self.follmeno[followerId] = [followeeId] elif followeeId not in self.follmeno[followerId]: self.follmeno[followerId].append(followeeId) def unfollow(self, followerId: int, followeeId: int) -> None: \"\"\" Follower unfollows a followee. If the operation is invalid, it should be a no-op. \"\"\" if followerId not in self.follmeno: return if followeeId in self.follmeno[followerId]: self.follmeno[followerId].remove(followeeId) Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-04-13 12:06:02 "},"leetcode/2020_04月/4.14.html":{"url":"leetcode/2020_04月/4.14.html","title":"4.14 T445.两数相加II","keywords":"","body":"4.14 T445.两数相加II 题目 给你两个 非空 链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。 你可以假设除了数字 0 之外，这两个数字都不会以零开头。 进阶： 如果输入链表不能修改该如何处理？换句话说，你不能对列表中的节点进行翻转。 示例： 输入：(7 -> 2 -> 4 -> 3) + (5 -> 6 -> 4) 输出：7 -> 8 -> 0 -> 7 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/add-two-numbers-ii 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解1 链表反转 相加 将结果再反转 如果题目不允许对原链表进行修改，就不能使用这个方法了。 其中第二步相加，有两种操作，一种是直接对原链表修改值；另一种是新建一个链表返回结果 这里我先使用的是第一种方法，代码有点麻烦，而且很慢(因为多了一些判断) 遂这里使用第二种，返回一个新链表存储结果。python3代码如下： # Definition for singly-linked list. # class ListNode: # def __init__(self, x): # self.val = x # self.next = None class Solution: def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode: # 反转链表 def myreverse(link): pre = None head = link while head: ne = head.next head.next = pre pre = head head = ne return pre carry = 0 head = ListNode(0) res = head rev_1, rev_2 = myreverse(l1), myreverse(l2) while rev_1 or rev_2: x = rev_1.val if rev_1 else 0 y = rev_2.val if rev_2 else 0 tmp = x + y + carry node = ListNode(tmp%10) carry = tmp//10 head.next = node head = node if rev_1: rev_1 = rev_1.next if rev_2: rev_2 = rev_2.next if carry>0: node = ListNode(carry) head.next = node return myreverse(res.next) 题解2 看来leetcode官方题解，运用栈反转。将两个链表依次压入栈中，然后退栈求和并进位，再用一个新链表返回结果。 class Solution: def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode: s1, s2 = [], [] while l1: s1.append(l1.val) l1 = l1.next while l2: s2.append(l2.val) l2 = l2.next ans = None carry = 0 while s1 or s2 or carry != 0: a = 0 if not s1 else s1.pop() b = 0 if not s2 else s2.pop() cur = a + b + carry carry = cur // 10 cur %= 10 curnode = ListNode(cur) curnode.next = ans ans = curnode return ans # 作者：LeetCode-Solution # 链接：https://leetcode-cn.com/problems/add-two-numbers-ii/solution/liang-shu-xiang-jia-ii-by-leetcode-solution/ # 来源：力扣（LeetCode） # 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-04-14 10:20:24 "},"leetcode/2020_04月/4.15.html":{"url":"leetcode/2020_04月/4.15.html","title":"4.15 T542.01矩阵","keywords":"","body":"4.15 T542.01矩阵 题目 给定一个由 0 和 1 组成的矩阵，找出每个元素到最近的 0 的距离。 两个相邻元素间的距离为 1 。 示例 1: 输入: 0 0 0 0 1 0 0 0 0 输出: 0 0 0 0 1 0 0 0 0 示例 2: 输入: 0 0 0 0 1 0 1 1 1 输出: 0 0 0 0 1 0 1 2 1 注意: 给定矩阵的元素个数不超过 10000。 给定矩阵中至少有一个元素是 0。 矩阵中的元素只在四个方向上相邻: 上、下、左、右。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/01-matrix 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解1 使用动态规划，用一个数组dp存储结果，dp[i][j]表示matrix[i][j]到最近0的距离。 使用两次遍历，第一次从左到右，从上到下。第二次从右到左，从下到上。 初始状态： 如果matrix[i][j]==0，则dp[i][j]=0； 状态转移： 左上 --> 右下：dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + 1 右下 --> 左上：dp[i][j] = min( dp[i][j], min(dp[i][j+1], dp[i+1][j])+1 ) python3代码 class Solution: def updateMatrix(self, matrix: List[List[int]]) -> List[List[int]]: m, n = len(matrix), len(matrix[0]) dp = [[0]*n for i in range(m)] for i in range(m): for j in range(n): if matrix[i][j]==0: dp[i][j] = 0 else: a = dp[i-1][j] if i-1>-1 else float('INF') b = dp[i][j-1] if j-1>-1 else float('INF') dp[i][j] = min(a, b) + 1 for i in range(m-1, -1, -1): for j in range(n-1, -1, -1): if matrix[i][j]==0: dp[i][j] = 0 else: a = dp[i+1][j] if i+1 时间复杂度$O(mn)$，空间复杂度$O(1)$(排除结果必须的空间)。 题解2 基本思想BFS广度优先搜索 找到所有值为0的坐标，并入队列 退队，广度优先搜索，向外辐射更新距离 class Solution: def updateMatrix(self, matrix: List[List[int]]) -> List[List[int]]: m, n = len(matrix), len(matrix[0]) dist = [[0] * n for _ in range(m)] zeroes_pos = [(i, j) for i in range(m) for j in range(n) if matrix[i][j] == 0] # 将所有的 0 添加进初始队列中 q = collections.deque(zeroes_pos) seen = set(zeroes_pos) # 广度优先搜索 while q: i, j = q.popleft() for ni, nj in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]: if 0 时间复杂度$O(mn)$，空间复杂度$O(mn)$，除答案数组外，最坏情况下矩阵里所有元素都为0，全部被加入队列中。 Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-04-15 11:20:53 "},"leetcode/2020_04月/4.16.html":{"url":"leetcode/2020_04月/4.16.html","title":"4.16 T56.合并区间","keywords":"","body":"4.16 T56.合并区间 题目 给出一个区间的集合，请合并所有重叠的区间。 示例 1: 输入: [[1,3],[2,6],[8,10],[15,18]] 输出: [[1,6],[8,10],[15,18]] 解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6]. 示例 2: 输入: [[1,4],[4,5]] 输出: [[1,5]] 解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/merge-intervals 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解1 使用栈。先将区间排序为列表li，则i li[i][0] 。再将li的元素依次压入栈中，每次压入栈中的区间左端点值必定递增。所以只用考虑栈顶区间是否重合。 class Solution: def merge(self, intervals: List[List[int]]) -> List[List[int]]: li = sorted(intervals) # li = sorted(intervals, key=lambda x:x[0]) stack = [] for a,b in li: if not stack: stack.append([a, b]) else: pa, pb = stack[-1] if astack[-1][1]: # stack.append([a, b]) # else: # stack[-1][1] = max(b, stack[-1][1]) return stack 时间复杂度：$O(n*logn)$，其中n为区间的数量。 空间复杂度：$O(logn)$，其中n为区间的数量。这里计算的是存储答案之外，使用的额外空间。$O(logn)$即为排序所需要的空间复杂度。 Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-04-16 09:39:05 "},"leetcode/2020_04月/4.17.html":{"url":"leetcode/2020_04月/4.17.html","title":"4.17 T55.跳跃游戏","keywords":"","body":"4.17 T55.跳跃游戏 题目 给定一个非负整数数组，你最初位于数组的第一个位置。 数组中的每个元素代表你在该位置可以跳跃的最大长度。 判断你是否能够到达最后一个位置。 示例 1: 输入: [2,3,1,1,4] 输出: true 解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。 示例 2: 输入: [3,2,1,0,4] 输出: false 解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/jump-game 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解 用列表nums存储最长跳跃长度，从左到右前进，每次可以到达地为跳跃起点i至i+nums[i]个位置，且i也必须可以被访问。 所以用一个数维护可到达的最远地点(维护最右数)，比该数小的地点都可以被访问，并实时更新。 class Solution: def canJump(self, nums: List[int]) -> bool: length = 0 for i in range(len(nums)): if i>length: return False if i+nums[i]>length: length = i+nums[i] if length>=len(nums)-1: return True return length>=len(nums)-1 Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-04-17 10:10:41 "},"leetcode/2020_04月/4.18.html":{"url":"leetcode/2020_04月/4.18.html","title":"4.18 T11.盛最多水的容器","keywords":"","body":"4.18 T11.盛最多水的容器 题目 给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 说明：你不能倾斜容器，且 n 的值至少为 2。 示例： 输入：[1,8,6,2,5,4,8,3,7] 输出：49 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/container-with-most-water 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解 双指针法，每次改变下限高度。 class Solution: def maxArea(self, height: List[int]) -> int: res = 0 left, right = 0, len(height)-1 while left 时间复杂度$O(n)$，空间复杂度$O(1)$。 Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-04-18 10:08:15 "},"leetcode/2020_04月/4.19.html":{"url":"leetcode/2020_04月/4.19.html","title":"4.19 T466.统计重复个数","keywords":"","body":"4.19 T466.统计重复个数 题目 由 n 个连接的字符串 s 组成字符串 S，记作 S = [s,n]。例如，[\"abc\",3]=“abcabcabc”。 如果我们可以从 s2 中删除某些字符使其变为 s1，则称字符串 s1 可以从字符串 s2 获得。例如，根据定义，\"abc\" 可以从 “abdbec” 获得，但不能从 “acbbe” 获得。 现在给你两个非空字符串 s1 和 s2（每个最多 100 个字符长）和两个整数 0 ≤ n1 ≤ 10^6 和 1 ≤ n2 ≤ 10^6。现在考虑字符串 S1 和 S2，其中 S1=[s1,n1] 、S2=[s2,n2] 。 请你找出一个可以满足使[S2,M] 从 S1 获得的最大整数 M 。 示例： 输入： s1 =\"acb\",n1 = 4 s2 =\"ab\",n2 = 2 返回： 2 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/count-the-repetitions 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解1 直接copy力扣的官方题解签到了。一天连着肝了三场比赛，先歇一歇，以后再补思考(已懂) class Solution: def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int: if n1 == 0: return 0 s1cnt, index, s2cnt = 0, 0, 0 # recall 是我们用来找循环节的变量，它是一个哈希映射 # 我们如何找循环节？假设我们遍历了 s1cnt 个 s1，此时匹配到了第 s2cnt 个 s2 中的第 index 个字符 # 如果我们之前遍历了 s1cnt' 个 s1 时，匹配到的是第 s2cnt' 个 s2 中同样的第 index 个字符，那么就有循环节了 # 我们用 (s1cnt', s2cnt', index) 和 (s1cnt, s2cnt, index) 表示两次包含相同 index 的匹配结果 # 那么哈希映射中的键就是 index，值就是 (s1cnt', s2cnt') 这个二元组 # 循环节就是； # - 前 s1cnt' 个 s1 包含了 s2cnt' 个 s2 # - 以后的每 (s1cnt - s1cnt') 个 s1 包含了 (s2cnt - s2cnt') 个 s2 # 那么还会剩下 (n1 - s1cnt') % (s1cnt - s1cnt') 个 s1, 我们对这些与 s2 进行暴力匹配 # 注意 s2 要从第 index 个字符开始匹配 recall = dict() while True: # 我们多遍历一个 s1，看看能不能找到循环节 s1cnt += 1 for ch in s1: if ch == s2[index]: index += 1 if index == len(s2): s2cnt, index = s2cnt + 1, 0 # 还没有找到循环节，所有的 s1 就用完了 if s1cnt == n1: return s2cnt // n2 # 出现了之前的 index，表示找到了循环节 if index in recall: s1cnt_prime, s2cnt_prime = recall[index] # 前 s1cnt' 个 s1 包含了 s2cnt' 个 s2 pre_loop = (s1cnt_prime, s2cnt_prime) # 以后的每 (s1cnt - s1cnt') 个 s1 包含了 (s2cnt - s2cnt') 个 s2 in_loop = (s1cnt - s1cnt_prime, s2cnt - s2cnt_prime) break else: recall[index] = (s1cnt, s2cnt) # ans 存储的是 S1 包含的 s2 的数量，考虑的之前的 pre_loop 和 in_loop ans = pre_loop[1] + (n1 - pre_loop[0]) // in_loop[0] * in_loop[1] # S1 的末尾还剩下一些 s1，我们暴力进行匹配 rest = (n1 - pre_loop[0]) % in_loop[0] for i in range(rest): for ch in s1: if ch == s2[index]: index += 1 if index == len(s2): ans, index = ans + 1, 0 # S1 包含 ans 个 s2，那么就包含 ans / n2 个 S2 return ans // n2 # 作者：LeetCode-Solution # 链接：https://leetcode-cn.com/problems/count-the-repetitions/solution/tong-ji-zhong-fu-ge-shu-by-leetcode-solution/ # 来源：力扣（LeetCode） # 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-05-05 10:10:51 "},"leetcode/2020_04月/4.20岛屿数量.html":{"url":"leetcode/2020_04月/4.20岛屿数量.html","title":"4.20 T200.岛屿数量","keywords":"","body":"4.20 T200.岛屿数量 题目 给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。 岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。 此外，你可以假设该网格的四条边均被水包围。 示例 1: 输入: 11110 11010 11000 00000 输出: 1 示例 2: 输入: 11000 11000 00100 00011 输出: 3 解释: 每座岛屿只能由水平和/或竖直方向上相邻的陆地连接而成。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/number-of-islands 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解 遍历问题 这里为使用DFS直接递归实现栈。 用一个数组visited记录是否已被访问。 遍历岛屿，若岛屿为陆地且未被访问，则作为源点DFS。 python3代码如下： class Solution: def numIslands(self, grid: List[List[str]]) -> int: # 处理空输入 if not grid: return 0 if not grid[0]: return 0 res = 0 self.m, self.n = len(grid), len(grid[0]) self.visited = [[0]*self.n for _ in range(self.m)] def dfs(ro, le): if -1 时间复杂度$O(MN)$，空间复杂度$O(MN)$。 上一个方法是在不改变岛屿的情况下，额外开辟一个visited记录访问，我们也可以直接改变岛屿数组值，如下 class Solution: def numIslands(self, grid: List[List[str]]) -> int: if not grid: return 0 if not grid[0]: return 0 res = 0 self.m, self.n = len(grid), len(grid[0]) def dfs(ro, le): if -1 时间复杂度$O(MN)$，空间复杂度$O(MN)$，最坏情况下岛屿全为陆地全部进栈。 执行时间比前一个方法稍微快一点。 Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-04-20 09:56:41 "},"leetcode/2020_04月/4.21统计优美子数组.html":{"url":"leetcode/2020_04月/4.21统计优美子数组.html","title":"4.21 T1248.统计「优美子数组」","keywords":"","body":"4.21 T1248.统计「优美子数组」 题目 给你一个整数数组 nums 和一个整数 k。 如果某个 连续 子数组中恰好有 k 个奇数数字，我们就认为这个子数组是「优美子数组」。 请返回这个数组中「优美子数组」的数目。 示例 1： 输入：nums = [1,1,2,1,1], k = 3 输出：2 解释：包含 3 个奇数的子数组是 [1,1,2,1] 和 [1,2,1,1] 。 示例 2： 输入：nums = [2,4,6], k = 1 输出：0 解释：数列中不包含任何奇数，所以不存在优美子数组。 示例 3： 输入：nums = [2,2,2,1,2,2,1,2,2,2], k = 2 输出：16 提示： 1 1 1 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/count-number-of-nice-subarrays 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解1 使用一个数组dp，dp[i]记录前i个数字中奇数的个数，然后找到所有满足dp[i]-dp[j]==k, j的个数。 class Solution: def numberOfSubarrays(self, nums: [int], k: int) -> int: res = 0 n = len(nums) dp = [0] * (n + 1) for i in range(n): if nums[i] & 1: dp[i + 1] = dp[i] + 1 else: dp[i + 1] = dp[i] for i in range(n + 1): for j in range(i): if dp[i] - dp[j] == k: res += 1 return res 时间复杂度$O(N^2)$，空间复杂度$O(N)$。leetcode过不了所有样例，超时。 题解2 对题解1进行改进，我们的目标是找到所有满足条件dp[i] - dp[j] == k, for j in range(i)的个数。 换句话说就是要找到，前j个数中奇数个数为dp[i]-k，满足该条件的j有多少个。 又因为j比i小；dp[i]表示前i个数字中奇数的个数，必定是递增的。即dp[i]-k递增 所以我们可以建立一个数组cntlist，cntlist[i]记录奇数个数为i的，从索引0开始的子串个数。 class Solution: def numberOfSubarrays(self, nums: [int], k: int) -> int: n = len(nums) res, odd = 0, 0 cntlist = [0]*(n+1) # 奇数个数为i的从0开始的子串个数 cntlist[0] = 1 for num in nums: if num&1: odd += 1 if odd>=k: res += cntlist[odd-k] cntlist[odd] += 1 return res 时间复杂度$O(N)$，空间复杂度$O(N)$。 题解3 找规律，以样例nums = [2,2,2,1,2,2,1,2,2,2], k = 2为例，满足条件的最小子串只有1221，左边有3个2，右边有3个2，左右分别可取0，1，2，3个数构成子串，所以一共有(3+1)x(3+1)=16种。 用数组ind，ind[i]记录nums中第i个奇数的索引。则以每个满足条件的最小子串为基，可构成的种数有： (ind[i]-ind[i-1])*(ind[i+k]-ind[i+k-1])，左边可取的偶数个数方案数 乘以 右边可取的偶数个数方案数。 class Solution: def numberOfSubarrays(self, nums: [int], k: int) -> int: ind = [-1] # 最左奇数的左边 for i in range(len(nums)): if nums[i]&1: ind.append(i) ind.append(len(nums)) # 最右奇数的右边 res = 0 for i in range(1, len(ind)-k): res += (ind[i]-ind[i-1])*(ind[i+k]-ind[i+k-1]) return res 时间复杂度$O(N)$，空间复杂度$O(N)$。 Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-04-30 15:44:14 "},"leetcode/2020_04月/4.22二叉树的右视图.html":{"url":"leetcode/2020_04月/4.22二叉树的右视图.html","title":"4.22 T199.二叉树的右视图","keywords":"","body":"4.22 T199.二叉树的右视图 题目 给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。 示例: 输入: [1,2,3,null,5,null,4] 输出: [1, 3, 4] 解释: 1 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/binary-tree-right-side-view 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解1 题目分析，二叉树的右视图，就是字面意思输出每层的最右节点值。 BFS宽度优先遍历，记录每层节点数，当节点数为0时说明该层节点已全部遍历完。 # Definition for a binary tree node. # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.right = None import collections class Solution: def rightSideView(self, root: TreeNode) -> List[int]: if not root: return [] queue = collections.deque() queue.append(root) cnt = 1 res = [] while queue: cur = queue.popleft() cnt -= 1 if cur.left: queue.append(cur.left) if cur.right: queue.append(cur.right) if cnt==0: res.append(cur.val) cnt = len(queue) # 更新下一层节点的数量 return res 时间复杂度$O(N)$，空间复杂度$O(N)$，最坏情况下所有节点都要入队。 题中使用了collections.deque()，是双端链表。如果使用列表list作为队列时，因为是数组实现，所以每次list.pop(0)左退队时间都是$O(N)$ 题解2 当然DFS也可以做，每次优先遍历右子树。但要记录遍历节点的深度，每次只输出同层最右节点值。 # Definition for a binary tree node. # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution: def rightSideView(self, root: TreeNode) -> List[int]: dep = set() # 记录深度 res = [] def dfs(node, depth): if not node: return # 如果没有出现，说明该节点是这一层的最右节点 if depth not in dep: res.append(node.val) dep.add(depth) dfs(node.right, depth+1) dfs(node.left, depth+1) dfs(root, 0) return res 时间复杂度$O(N)$，空间复杂度$O(N)$，最坏情况下所有节点都要入栈。 Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-04-22 10:54:03 "},"leetcode/2020_04月/4.23硬币.html":{"url":"leetcode/2020_04月/4.23硬币.html","title":"4.23 面试题08.11.硬币","keywords":"","body":"4.23 面试题08.11.硬币 题目 硬币。给定数量不限的硬币，币值为25分、10分、5分和1分，编写代码计算n分有几种表示法。(结果可能会很大，你需要将结果模上1000000007) 示例1: 输入: n = 5 输出：2 解释: 有两种方式可以凑成总金额: 5=5 5=1+1+1+1+1 示例2: 输入: n = 10 输出：4 解释: 有四种方式可以凑成总金额: 10=10 10=5+5 10=5+1+1+1+1+1 10=1+1+1+1+1+1+1+1+1+1 注意:你可以假设： 0 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/coin-lcci 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解1 动态规划 第一步：定义状态，及转移方程。 f[k][v]表示使用前k种硬币表示金额v的方法数，硬币列表coins = [25, 10, 5, 1]。 那么： f[k][v] = f[k-1][v] + f[k-1][v-coins[k]] + f[k-1][v-2*coins[k]] + ... + f[k-1][v-j*coins[k]] j = v//coins[k] 理解起来就是，使用前k个硬币表示金额v的方法数等于，使用第k枚硬币数为0 加上 使用第k枚硬币数为1 加上.... 简化一下： 因为f[k][v-coins[k]] = f[k-1][v-coins[k]] + f[k-1][v-2*coins[k]] + ... + f[k-1][v-j*coins[k]] 两式相减得：f[k][v] - f[k][v-coins[k]] = f[k-1][v] 即：f[k][v] = f[k-1][v] + f[k][v-coins[k]] 观察到转移方程中的f[k][v]和f[k-1][v]，我们遍历coins相当于遍历k，类似前一个状态的自加，所以将状态定义简化为一维： dp[i]表示使用coins表示金额i的方法数，dp[0] = 1 状态转移：dp[i] += dp[i-coins[k]] for k in range(len(coins)) class Solution: def waysToChange(self, n: int) -> int: coins = [1, 5, 10, 25] MOD = int(1e9+7) dp = [0]*(n+1) dp[0] = 1 # 先遍历coins，对应f[k-1][v]自加 for c in coins: for i in range(c, n+1): dp[i] += dp[i-c] dp[i] %= MOD return dp[-1] 时间复杂度$O(N)$，空间复杂度$O(N)$。 二维的状态f[k][v]也写了下 def waysToChange_0(self, n:int): coins = [1, 5, 10, 25] MOD = int(1e9+7) f = [[0]*(n+1) for _ in range(len(coins)+1)] # 金额为0，则只有一种方案，硬币数全为0 for i in range(len(coins)+1): f[i][0] = 1 for v in range(1, n+1): for k in range(1, len(coins)+1): if v>=coins[k-1]: f[k][v] = f[k-1][v] + f[k][v-coins[k-1]] else: f[k][v] = f[k-1][v] f[k][v] %= MOD return f[-1][-1] 题解2 数学方法，因为只有四种硬币，不多可以枚举。 对25的硬币枚举。对于i个25元硬币，就可以直接计算有多少种方案了。 a = n//25枚举25元硬币数量为i，最后用1元硬币补足余额 r = n-25*i; b=r//10; c=r//5 硬币种类 | 25 | 10 | 5 | 1 ---|---|---|---|--- 数量|i|0|c|... ^|i|1|c-2|... ^|i|2|c-4|... ^|i|...|...|... ^|i|b|c-2*b|... 所以当选i枚25硬币时，由等差数列求和得： $(c+1) + (c-2+1) + ···· + (c-2 b+1) = \\frac{2 c + 2 b + 2}{2} (b+1) = (1+c-b)*(b+1)$ def waysToChange_1(self, n: int): a = n//25 res = 0; MOD = int(1e9+7) for i in range(a+1): # 不能枚举10，否则时间复杂度为N^2 # r = n - 25*i # b = r//10 # for j in range(b+1): # c = (r-j*10)//5 # res += c+1 # res %= MOD r = n - 25*i b = r//10; c = r//5 res += (1+c-b)*(b+1) res %= MOD return res 时间复杂度$O(N)$，空间复杂度$O(1)$。 Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-05-03 11:39:32 "},"leetcode/2020_04月/4.24数组中的逆序对.html":{"url":"leetcode/2020_04月/4.24数组中的逆序对.html","title":"4.24 面试题51.数组中的逆序对","keywords":"","body":"4.24 面试题51.数组中的逆序对 题目 在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。 示例 1: 输入: [7,5,6,4] 输出: 5 限制： 0 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解1 数组长度最大50000，如果暴力$O(N^2)$，会超时。 这里采用边算边排序。 import bisect class Solution: def reversePairs(self, nums: [int]) -> int: def bfind(left, right, nums, n): i, j = left, right while i>1 if n 因为使用了list.insert()，所以复杂度还是有点高，$O(n^2)$。 题解2 使用归并排序思想。左右两段已排序，归并进数组tmps。 在归并过程中，出现逆序情况只有当左段插入tmps时，当前tmps中已插入的右段元素个数。 举例： 左段：[3, 6, 9, 10, 11]，右段：[1, 5, 8, 10, 12] 左段使用P，右段使用Q控制。 P=0, Q=0; tmps = [] P=0, Q=1; tmps = [1] P=1, Q=1; tmps = [1, 3] ; res += 1 P=1, Q=2; tmps = [1, 3, 5] P=2, Q=2; tmps = [1, 3, 5, 6] ; res += 2 ... 每次当从左段添加数a时，则和a可构成逆序对数量 为此时的Q值(表示此时已添加的右段数的个数)。 class Solution: def reversePairs(self, nums: List[int]) -> int: tmps = [0]*len(nums) def mergesort(nums, left, right): if left>=right: return 0 mid = (left+right)>>1 res = mergesort(nums, left, mid) + mergesort(nums, mid+1, right) P, Q = left, mid+1 X = 0 while P 时间复杂度$O(nlogn)$，空间复杂度$O(n)$。速度比题解1快很多。 题解3 使用离散的树状数组。把nums中的每个数倒序装进桶里，考虑逆序对数时，就是当前桶里比自己小(左边)的数量和。 例：nums = [4, 8, 5, 2, 5] 对应桶： ind = 012345678 cnt = 001012001 把nums倒序入桶，求逆序数量和。当k入桶时，即是求当前桶cnt中左边k个数的和。 class Solution: def reversePairs(self, nums: [int]) -> int: \"\"\" 使用树状数组 \"\"\" class BIT: # 构建树状数组 def __init__(self, n): self.n = n self.tree = [0]*(n+1) def lowbit(self, x): # return (x ^ (x-1))&x return (-x)&x def get_sum(self, k): res = 0 while k>0: res += self.tree[k] k -= self.lowbit(k) return res def update(self, k, value): while k Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-04-25 15:23:46 "},"leetcode/2020_04月/4.25全排列.html":{"url":"leetcode/2020_04月/4.25全排列.html","title":"4.25 T46.全排列","keywords":"","body":"4.25 T46.全排列 题目 给定一个 没有重复 数字的序列，返回其所有可能的全排列。 示例: 输入: [1,2,3] 输出: [ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1] ] 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/permutations 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解1 DFS深度优先遍历 class Solution: def permute(self, nums: List[int]) -> List[List[int]]: def dfs(s, tmp): if not s: res.append(tmp[:]) # 添加副本，否则之后tmp的改动会对结果造成影响 return for i in s: tmp.append(i) a = s.copy() # 拷贝一份集合 a.remove(i) dfs(a, tmp) tmp.pop() # 撤销上次的操作 res = [] dfs(set(nums), []) return res 简化一下代码，将手动复制隐藏到列表相加里 class Solution: def permute(self, nums: List[int]) -> List[List[int]]: def dfs(li, tmp): if not li: res.append(tmp) return for i in range(len(li)): # 列表相加，自带复制了，所以不用撤回操作和手动复制 dfs(li[:i]+li[i+1:], tmp+[li[i]]) res = [] dfs(nums, []) return res 当然使用python内置包也可以做 import itertools class Solution: def permute(self, nums: List[int]) -> List[List[int]]: li = [] for i in itertools.permutations(nums): li.append(list(i)) return li Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-04-25 10:31:22 "},"leetcode/2020_04月/4.26合并K个排序链表.html":{"url":"leetcode/2020_04月/4.26合并K个排序链表.html","title":"4.26 T23.合并K个排序链表","keywords":"","body":"4.26 T23.合并K个排序链表 题目 合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。 示例: 输入: [ 1->4->5, 1->3->4, 2->6 ] 输出: 1->1->2->3->4->4->5->6 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/merge-k-sorted-lists 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解1 对K个有序链表的第一个节点，选择值最小的节点加入到结果链表中，并将该链表的头进一步。 # Definition for singly-linked list. # class ListNode: # def __init__(self, x): # self.val = x # self.next = None class Solution: def mergeKLists(self, lists: List[ListNode]) -> ListNode: li = lists head = ListNode(0) cur = head n = len(li) INF = float('INF') while n>0: ind = 0 tmp = INF for i in range(len(li)): if li[i] and li[i].val 题解2 两两合并，依次进行。 ## 参见leetcode提交记录的一个范例 # Definition for singly-linked list. class ListNode: def __init__(self, x): self.val = x self.next = None class Solution: def mergeKLists(self, lists): if len(lists) == 0: return None while len(lists) > 1: l1 = lists.pop(0) l2 = lists.pop(0) lists.append(self.merge2lists(l1, l2)) return lists[0] def merge2lists(self, l1, l2): if not l1: return l2 if not l2: return l1 head = ListNode(0) p = head while l1 is not None and l2 is not None: if l1.val 题解3 先将遍历所有链表的节点，将其值加入堆中排序。然后依次退堆建链表。 # Definition for singly-linked list. # class ListNode: # def __init__(self, x): # self.val = x # self.next = None import heapq # 使用python自带堆模块(默认小顶堆) class Solution: def mergeKLists(self, lists: List[ListNode]) -> ListNode: heap = [] for node in lists: while node: heapq.heappush(heap, node.val) node = node.next head = ListNode(0) p = head while heap: value = heapq.heappop(heap) p.next = ListNode(value) p = p.next return head.next Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-04-26 17:34:52 "},"leetcode/2020_04月/4.27搜索旋转排序数组.html":{"url":"leetcode/2020_04月/4.27搜索旋转排序数组.html","title":"4.27 T33.搜索旋转排序数组","keywords":"","body":"4.27 T33.搜索旋转排序数组 题目 假设按照升序排序的数组在预先未知的某个点上进行了旋转。 (例如，数组[0,1,2,4,5,6,7]可能变为[4,5,6,7,0,1,2])。 搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。 你可以假设数组中不存在重复的元素。 你的算法时间复杂度必须是 O(log n) 级别。 示例 1: 输入: nums = [4,5,6,7,0,1,2], target = 0 输出: 4 示例 2: 输入: nums = [4,5,6,7,0,1,2], target = 3 输出: -1 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/search-in-rotated-sorted-array 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解1 如题时间复杂度为$O(log n)$，则二分查找。 自己的代码虽然AC了，但写的太烂，ifelse太多。 官方代码思路简洁。mid = (left+right)>>1 如果[left, mid-1]是有序数组，且 target 的大小满足nums[left] ，则我们应该将搜索范围缩小至[left, mid-1]，否则在[mid + 1,right]中寻找。 如果[mid, right]是有序数组，且 target 的大小满足nums[mid] ，则我们应该将搜索范围缩小至 [mid + 1, right]，否则在 [left, mid - 1] 中寻找。 class Solution: def search(self, nums: List[int], target: int) -> int: if not nums: return -1 l, r = 0, len(nums) - 1 while l 时间复杂度$O(log n)$，空间复杂度$O(1)$。 Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-04-29 10:25:46 "},"leetcode/2020_04月/4.28数组中数字出现的次数.html":{"url":"leetcode/2020_04月/4.28数组中数字出现的次数.html","title":"4.28 面试题56-I.数组中数字出现的次数","keywords":"","body":"4.28 面试题56-I.数组中数字出现的次数 题目 一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。 示例 1： 输入：nums = [4,1,4,6] 输出：[1,6] 或 [6,1] 示例 2： 输入：nums = [1,2,10,4,1,4,3,3] 输出：[2,10] 或 [10,2] 限制： 2 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解1 题目要求空间复杂度为$O(1)$。先来看如果一个数组中只有一个数出现一次，其他的数都是两次，如何做？ 考虑异或操作，对应位相同则为0，不同为1。所以两个相同的数异或后为0，0与任何数异或为其自身。并且异或满足结合律。 所以直接遍历数组，两两异或，最终得到的就是结果。而我们这次的是有两个出现次数为1的数，那么把数组分为两组，每组一个就解决了。 设出现次数为1的两个数为a、b，则数组全部异或结果为a^b，若a^b的二进制某一位为1，按照该位二进制为0或1对数组分组即可。 import functools class Solution: def singleNumbers(self, nums: List[int]) -> List[int]: res = functools.reduce(lambda x,y: x^y, nums) # ind = res & (-res) # 与下面三行代码效果相同 ind = 1 while (res & ind) == 0: ind 题解2 空间复杂度$O(n)$，用python的字典结构 class Solution: def singleNumbers(self, nums: List[int]) -> List[int]: meno = {} for i in nums: if i not in meno: meno[i]=1 else: meno.pop(i) return [x for x in meno.keys()] Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-04-28 09:46:23 "},"leetcode/2020_04月/4.29山脉数组中查找目标值.html":{"url":"leetcode/2020_04月/4.29山脉数组中查找目标值.html","title":"4.29 T1095.山脉数组中查找目标值","keywords":"","body":"4.29 T1095.山脉数组中查找目标值 题目 给你一个 山脉数组 mountainArr，请你返回能够使得 mountainArr.get(index) 等于 target 最小 的下标 index 值。 如果不存在这样的下标 index，就请返回 -1。 何为山脉数组？如果数组 A 是一个山脉数组的话，那它满足如下条件： 首先，A.length >= 3 其次，在 0 A[0] A[i+1] > ... > A[A.length - 1] 你将 不能直接访问该山脉数组，必须通过 MountainArray 接口来获取数据： MountainArray.get(k) - 会返回数组中索引为k 的元素（下标从 0 开始） MountainArray.length() - 会返回该数组的长度 注意： 对 MountainArray.get 发起超过 100 次调用的提交将被视为错误答案。此外，任何试图规避判题系统的解决方案都将会导致比赛资格被取消。 示例 1： 输入：array = [1,2,3,4,5,3,1], target = 3 输出：2 解释：3 在数组中出现了两次，下标分别为 2 和 5，我们返回最小的下标 2。 示例 2： 输入：array = [0,1,2,4,2,1], target = 3 输出：-1 解释：3 在数组中没有出现，返回 -1。 提示： 3 0 0 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/find-in-mountain-array 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解1 因为题目要求调用get()次数不超过100次，而数组长度为3~10000，则不能用线性从左到右判断。 如果数组单调，则可以使用二分查找在$O(log n)$的时间复杂度里找到target。现数组形如山脉，在山峰左侧是单调增，山峰右测是单调减。如果我们可以找到山峰索引，再在两侧分别用二分即可。 也可以使用二分找到山峰，由山脉特征得，若mountain_arr.get(mid)>mountain_arr.get(mid+1)，说明山峰在mid左侧，即令right=mid；若mountain_arr.get(mid)，说明山峰在mid右侧，即令left=mid+1。 详见代码 # \"\"\" # This is MountainArray's API interface. # You should not implement it, or speculate about its implementation # \"\"\" #class MountainArray: # def get(self, index: int) -> int: # def length(self) -> int: class Solution: def findInMountainArray(self, target: int, mountain_arr: 'MountainArray') -> int: topind = 0 n = mountain_arr.length() # 找到山峰索引 left, right = 0, n-1 while left>1 diff = mountain_arr.get(mid)-mountain_arr.get(mid+1) if diff>0: right = mid else: left = mid+1 topind = left # print(topind) # 二分查找 # rever表示‘逆序’，0表示左侧，1表示右侧 # 因为在山峰左侧如果get(mid)>target，则说明目标值在mid左侧 # 而在山峰右侧如果get(mid)>target，则说明目标值在mid右侧。 def twofind(ll, rr, target, rever): res = 0 while ll>1 tmp = mountain_arr.get(mid) if (tmp>target)^rever: rr = mid elif (tmp 时间复杂度：$O(logn)$，我们进行了三次二分搜索，每次的时间复杂度都为$O(logn)$。 空间复杂度：$O(1)$，只需要常数的空间存放若干变量。 Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-04-29 10:22:15 "},"leetcode/2020_04月/4.30快乐数.html":{"url":"leetcode/2020_04月/4.30快乐数.html","title":"4.30 T202.快乐数","keywords":"","body":"4.30 T202.快乐数 题目1 编写一个算法来判断一个数 n 是不是快乐数。 「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。如果 可以变为 1，那么这个数就是快乐数。 如果 n 是快乐数就返回 True ；不是，则返回 False 。 示例： 输入：19 输出：true 解释： 12 + 92 = 82 82 + 22 = 68 62 + 82 = 100 12 + 02 + 02 = 1 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/happy-number 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解1 依次求各位数平方和，再用一个哈希表存储结果，防止进入循环。 首先分析每次求下一个数可能有几种情况： 下一个数为1，找到值，返回True 下一个数之前已经算过，在哈希表中，进入循环。返回False 下一个数越来越大，一直趋于无穷。 当x为n位数时(n>3)，下一个数最大为81*n，又因为81*n ，所以x必定越来越小，直至三位数。 三位数最大为999，999下一个数为81*3 = 243。所以如果该数不是快乐数，则最后一定是在243内循环。第三种情况不可能发生。 所以可以放心的使用哈希表存储结果 class Solution: def isHappy(self, n: int) -> bool: visited = set() a = n visited.add(a) while a!=1: tmp = 0 for i in str(a): tmp += int(i)**2 a = tmp if a not in visited: visited.add(a) else: break return a==1 时间复杂度$O(log n)$，空间复杂度$O(log n)$ ？？？ 题解2 快慢指针法，由1的分析，一个数按快乐数求法，最终要么为1，要么进入已出现的循环中。 使用两个变量，快变量每次算x的下下一个数，慢变量算x的下一个数。 如果该数x是快乐数，则快变量肯定先为1，返回True即可。 若不是快乐数，则必定经过有限次前进，快变量和慢变量值相同。 时间复杂度$O(log n)$？？？，空间复杂度$O(1)$ 题解3 由1分析，得如果一个数不是快乐数，它必将进入循环。那么存不存在一个循环链，使得所有非快乐数最终都在该循环链中。 会发现只有一个循环：$4 \\rightarrow 16 \\rightarrow 37 \\rightarrow 58 \\rightarrow 89 \\rightarrow 145 \\rightarrow 42 \\rightarrow 20 \\rightarrow 4$。所有其他数字都在进入这个循环的链上，或者在进入 11 的链上。 作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/happy-number/solution/kuai-le-shu-by-leetcode-solution/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 def isHappy(self, n: int) -> bool: cycle_members = {4, 16, 37, 58, 89, 145, 42, 20} def get_next(number): total_sum = 0 while number > 0: number, digit = divmod(number, 10) total_sum += digit ** 2 return total_sum while n != 1 and n not in cycle_members: n = get_next(n) return n == 1 # 作者：LeetCode-Solution # 链接：https://leetcode-cn.com/problems/happy-number/solution/kuai-le-shu-by-leetcode-solution/ # 来源：力扣（LeetCode） # 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 时间复杂度$O(log n)$？？？，空间复杂度$O(1)$。 Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-04-30 12:24:43 "},"leetcode/2020_05月/":{"url":"leetcode/2020_05月/","title":"5月每题","keywords":"","body":"5月每题 Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-05-04 16:51:12 "},"leetcode/2020_05月/5.01最大子序和.html":{"url":"leetcode/2020_05月/5.01最大子序和.html","title":"5.01 T53.最大子序和","keywords":"","body":"5.01 T53.最大子序和 题目 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 示例: 输入: [-2,1,-3,4,-1,2,1,-5,4], 输出: 6 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。 进阶: 如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/maximum-subarray 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解1 class Solution: def maxSubArray(self, nums: List[int]) -> int: res = -2**31 ans = 0 for i in nums: if ans>0: ans += i else: ans = i res = max(res, ans) return res 题解2 分治法参见leetcode官方题解 Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-05-04 18:20:24 "},"leetcode/2020_05月/5.02合并两个有序链表.html":{"url":"leetcode/2020_05月/5.02合并两个有序链表.html","title":"5.02 T21.合并两个有序链表","keywords":"","body":"5.02 T21.合并两个有序链表 题目 将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例： 输入：1->2->4, 1->3->4 输出：1->1->2->3->4->4 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/merge-two-sorted-lists 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解1 # Definition for singly-linked list. # class ListNode: # def __init__(self, x): # self.val = x # self.next = None class Solution: def mergeTwoLists(self, l1: ListNode, l2: ListNode) -> ListNode: head = ListNode(0) cur = head p, q = l1, l2 while p and q: if p.val Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-05-04 18:21:48 "},"leetcode/2020_05月/5.03无重复字符的最长子串.html":{"url":"leetcode/2020_05月/5.03无重复字符的最长子串.html","title":"5.03 T3.无重复字符的最长子串","keywords":"","body":"5.03 T3.无重复字符的最长子串 题目 给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 示例 1: 输入: \"abcabcbb\" 输出: 3 解释: 因为无重复字符的最长子串是 \"abc\"，所以其长度为 3。 示例 2: 输入: \"bbbbb\" 输出: 1 解释: 因为无重复字符的最长子串是 \"b\"，所以其长度为 1。 示例 3: 输入: \"pwwkew\" 输出: 3 解释: 因为无重复字符的最长子串是 \"wke\"，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，\"pwke\" 是一个子序列，不是子串。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/longest-substring-without-repeating-characters 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解1 class Solution: def lengthOfLongestSubstring(self, s: str) -> int: if not s: return 0 left, right = 0, 0 # left为子串左端点索引 n = len(s) meno = {} # 键值对存储字母：索引 res = 0; cnt = 0 while right Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-05-04 18:26:02 "},"leetcode/2020_05月/5.04跳跃游戏II.html":{"url":"leetcode/2020_05月/5.04跳跃游戏II.html","title":"5.04 T45.跳跃游戏II","keywords":"","body":"5.04 T45.跳跃游戏II 题目 给定一个非负整数数组，你最初位于数组的第一个位置。 数组中的每个元素代表你在该位置可以跳跃的最大长度。 你的目标是使用最少的跳跃次数到达数组的最后一个位置。 示例: 输入: [2,3,1,1,4] 输出: 2 解释: 跳到最后一个位置的最小跳跃数是 2。 从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。 说明: 假设你总是可以到达数组的最后一个位置。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/jump-game-ii 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解1 如果记录数组每个位置到达需要的最短步数，则步数必定是递增的。即假如数组索引i，到达nums[i]需要x步，那么到达nums[j]必定大于等于x步。 left记录cnt步能到达的最右索引。 class Solution: def jump(self, nums: List[int]) -> int: if len(nums)right: right = i+nums[i] if i==left: left = right cnt += 1 if left>=n-1: return cnt return cnt 题解2 动态规划，超时 class Solution: def jump(self, nums: List[int]) -> int: if len(nums) 时间复杂度$O(n^2)$ Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-05-04 20:19:23 "},"leetcode/2020_05月/5.05验证二叉搜索树.html":{"url":"leetcode/2020_05月/5.05验证二叉搜索树.html","title":"5.05 T98.验证二叉搜索树","keywords":"","body":"5.05 T98.验证二叉搜索树 题目 给定一个二叉树，判断其是否是一个有效的二叉搜索树。 假设一个二叉搜索树具有如下特征： 节点的左子树只包含小于当前节点的数。 节点的右子树只包含大于当前节点的数。 所有左子树和右子树自身必须也是二叉搜索树。 示例 1:输入: 2 / \\ 1 3 输出: true 示例 2:输入: 5 / \\ 1 4 / \\ 3 6 输出: false 解释: 输入为: [5,1,4,null,null,3,6]。 根节点的值为 5 ，但是其右子节点值为 4 。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/validate-binary-search-tree 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解1 使用二叉搜索数的特点，其中序遍历是一个递增序列。 # Definition for a binary tree node. # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution: def isValidBST(self, root: TreeNode) -> bool: if not root: return True # 中序遍历 def visit(root): if not root: return visit(root.left) li.append(root.val) visit(root.right) li = [] visit(root) # 验证是否是递增序列 tmp = li[0] for i in range(1, len(li)): if li[i] 题解1.1 当然我代码写的不够优雅，可以简化，在中序遍历过程中就可以直接判断序列是否递增。 class Solution: def isValidBST(self, root): \"\"\" :type root: TreeNode :rtype: bool \"\"\" stack, inorder = [], float('-inf') while stack or root: while root: stack.append(root) root = root.left root = stack.pop() # 如果中序遍历得到的节点的值小于等于前一个 inorder，说明不是二叉搜索树 if root.val 题解2 根据根节点值大于左子树，小于右子树，则左子树节点值, 右子树节点值>root.val。且左右子树同样是二叉搜索数。 直接递归判断两边子树值的范围是否越界。 class Solution: def isValidBST(self, root): \"\"\" :type root: TreeNode :rtype: bool \"\"\" def helper(node, lower = float('-inf'), upper = float('inf')): if not node: return True val = node.val if val = upper: return False if not helper(node.right, val, upper): return False if not helper(node.left, lower, val): return False return True return helper(root) # 作者：LeetCode-Solution # 链接：https://leetcode-cn.com/problems/validate-binary-search-tree/solution/yan-zheng-er-cha-sou-suo-shu-by-leetcode-solution/ # 来源：力扣（LeetCode） # 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-05-05 10:20:50 "},"leetcode/2020_05月/5.06最低票价.html":{"url":"leetcode/2020_05月/5.06最低票价.html","title":"5.06 T983.最低票价","keywords":"","body":"5.06 T983.最低票价 题目 在一个火车旅行很受欢迎的国度，你提前一年计划了一些火车旅行。在接下来的一年里，你要旅行的日子将以一个名为 days 的数组给出。每一项是一个从 1 到 365 的整数。 火车票有三种不同的销售方式： 一张为期一天的通行证售价为 costs[0] 美元； 一张为期七天的通行证售价为 costs[1] 美元； 一张为期三十天的通行证售价为 costs[2] 美元。 通行证允许数天无限制的旅行。 例如，如果我们在第2天获得一张为期7天的通行证，那么我们可以连着旅行7天：第2天、第3天、第4天、第5天、第6天、第7天和第8天。 返回你想要完成在给定的列表 days 中列出的每一天的旅行所需要的最低消费。 示例 1： 输入：days = [1,4,6,7,8,20], costs = [2,7,15] 输出：11 解释： 例如，这里有一种购买通行证的方法，可以让你完成你的旅行计划： 在第 1 天，你花了 costs[0] = $2 买了一张为期 1 天的通行证，它将在第 1 天生效。 在第 3 天，你花了 costs[1] = $7 买了一张为期 7 天的通行证，它将在第 3, 4, ..., 9 天生效。 在第 20 天，你花了 costs[0] = $2 买了一张为期 1 天的通行证，它将在第 20 天生效。 你总共花了 $11，并完成了你计划的每一天旅行。 示例 2： 输入：days = [1,2,3,4,5,6,7,8,9,10,30,31], costs = [2,7,15] 输出：17 解释： 例如，这里有一种购买通行证的方法，可以让你完成你的旅行计划： 在第 1 天，你花了 costs[2] = $15 买了一张为期 30 天的通行证，它将在第 1, 2, ..., 30 天生效。 在第 31 天，你花了 costs[0] = $2 买了一张为期 1 天的通行证，它将在第 31 天生效。 你总共花了 $17，并完成了你计划的每一天旅行。 提示： 1 1 days 按顺序严格递增 costs.length == 3 1 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/minimum-cost-for-tickets 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解1 动态规划，money[i]记录一年中第1天到第i天满足旅行计划的最小花费，len(money)=366。 使用数组f[i]记录当天是否旅行，若f[i]==1则表明第i天要旅行，否则第i天不旅行。 money[i] = min(money[i-ticketdays[j]]+costs[j]) for j in (0, 1, 2)，ticketdays=[1, 7, 30] 第i天分别属于1天票、7天票或30天票中的最小花费。 class Solution: def mincostTickets(self, days: [int], costs: [int]) -> int: f = [0] * 366 for i in days: f[i] = 1 money = [0] * 366 for i in range(1, len(f)): if f[i] == 0: money[i] = money[i - 1] continue tmp = money[i - 1] + costs[0] for j in range(1, 3): if j == 1: a = money[i - 7] if i - 7 > 0 else 0 tmp = min(tmp, a + costs[1]) if j == 2: a = money[i - 30] if i - 30 > 0 else 0 tmp = min(tmp, a + costs[2]) money[i] = tmp # for i in range(len(f)): # print(f'i={i}, f[{i}]={f[i]}, money[{i}]={money[i]}') return money[-1] 时间复杂度$O(M)$，M为一年的天数365。$O(3M) = O(M)$ 空间复杂度$O(M)$，$O(2M) = O(M)$ 题解2 看一下官方的动态规划，使用了递归，自顶向下。 第一天在三种方案里选最优，再递归求子方案最优。。。 dp[i]表示从第i天到第365天满足计划的最小花费。 python默认递归深度为1000，不够要手动修改 from functools import lru_cache # 实现记忆化，类似动态规划保存了中间值 import sys class Solution: def mincostTickets(self, days: List[int], costs: List[int]) -> int: sys.setrecursionlimit(5000) # 更改递归深度 dayset = set(days) durations = [1, 7, 30] # @lru_cache(None)对记忆存储量没有上限，可@lru_cache(maxsize=400)规定记忆上限 @lru_cache(None) def dp(i): if i > 365: return 0 elif i in dayset: return min(dp(i + d) + c for c, d in zip(costs, durations)) else: return dp(i + 1) return dp(1) # 作者：LeetCode-Solution # 链接：https://leetcode-cn.com/problems/minimum-cost-for-tickets/solution/zui-di-piao-jie-by-leetcode-solution/ # 来源：力扣（LeetCode） # 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-05-09 11:40:51 "},"leetcode/2020_05月/5.07另一个树的子树.html":{"url":"leetcode/2020_05月/5.07另一个树的子树.html","title":"5.07 T572.另一个树的子树","keywords":"","body":"5.07 T572.另一个树的子树 题目 给定两个非空二叉树 s 和 t，检验 s 中是否包含和 t 具有相同结构和节点值的子树。s 的一个子树包括 s 的一个节点和这个节点的所有子孙。s 也可以看做它自身的一棵子树。 示例 1: 给定的树 s: 3 / \\ 4 5 / \\ 1 2 给定的树 t： 4 / \\ 1 2 返回 true，因为 t 与 s 的一个子树拥有相同的结构和节点值。 示例 2: 给定的树 s： 3 / \\ 4 5 / \\ 1 2 / 0 给定的树 t： 4 / \\ 1 2 返回 false。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/subtree-of-another-tree 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解1 递归考察 # Definition for a binary tree node. # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution: def isSubtree(self, s: TreeNode, t: TreeNode) -> bool: # 判断两个子树一模一样 def same(s, t): return (s==t) \\ or (s and t and s.val==t.val and same(s.left, t.left) and same(s.right, t.right)) def func(s, t): if not s and not t: return True if not (s and t): return False if s.val == t.val and same(s, t): return True return func(s.left, t) or func(s.right, t) return func(s, t) 设树s节点个数cnt1，树t节点个数cnt2。则时间复杂度为$O(cnt1*cnt2)$，最坏情况对s中每一个点和t做一次匹配，每次匹配最坏执行cnt2次。 空间复杂度$O(max(depth_s, depth_t))$ 执行时间252 ms，在所有 Python3 提交中击败了56.57%的用户。 题解2 先序遍历树(DFS)，对左空子树和右空子树分别记lnull和rnull，这样DFS得到的序列才唯一确定一颗树(待证) 再用字符串匹配算法在树s的DFS序列中找树t的DFS序列，若能够找到其子串则返回True。否则返回False。 时间复杂度$O(cnt1 + cnt2)$。遍历时间复杂度$O(cnt1 + cnt2)$，KMP匹配$O(cnt1 + cnt2)$。 空间复杂度$O(cnt1 + cnt2)$。 题解3 树哈希，设计哈希函数，对s的每一个节点作为root得到一个hash值，再将t哈希。每一个哈希值都大概率唯一的对应一种树，若t树的哈希值在s的每一个子树hash值里，则返回True，否则返回False。 需要设计好的树哈希函数。 基本是按官解c++复刻成python3的。 from functools import lru_cache import sys class Solution: def isSubtree(self, s: TreeNode, t: TreeNode) -> bool: sys.setrecursionlimit(5000) # 改变递归深度 MAX_N = 10000+5 # 官解是1005个，第12个案例list越界，改成10005个就都AC了 MOD = int(1e9+7) p = [] def getPrime(): vis = [0]*MAX_N vis[0] = vis[1] = 1 for i in range(2, MAX_N): if vis[i]==0: p.append(i) j = 0 while j 时间复杂度$O(max(cnt1, cnt2)c)$，空间复杂度$O(max(cnt1, cnt2)c)$。 疑问：执行时间812 ms，在所有 Python3 提交中击败了5.33%的用户。反而比题解1的暴力递归都慢。 Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-05-07 17:54:02 "},"leetcode/2020_05月/5.08最大正方形.html":{"url":"leetcode/2020_05月/5.08最大正方形.html","title":"5.08 T221.最大正方形","keywords":"","body":"5.08 T221.最大正方形 题目 在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。 示例: 输入: 1 0 1 0 0 1 0 1 1 1 1 1 1 1 1 1 0 0 1 0 输出: 4 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/maximal-square 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解1 动态规划，dp[i][j]表示构成正方形的最长斜对角线长度。 class Solution: def maximalSquare(self, matrix: List[List[str]]) -> int: if not matrix or not matrix[0]: return 0 m, n = len(matrix), len(matrix[0]) dp = [[0]*(n+1) for _ in range(m+1)] # 方便下面的转移方程，不用考虑0边界 res = 0 for i in range(m): for j in range(n): if matrix[i][j]=='1': dp[i+1][j+1] = min(dp[i][j+1], dp[i+1][j], dp[i][j]) + 1 res = max(res, dp[i+1][j+1]) # for i in dp: # print(i) return res**2 Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-05-09 12:29:01 "},"leetcode/2020_05月/5.09x的平方根.html":{"url":"leetcode/2020_05月/5.09x的平方根.html","title":"5.09 T69.x的平方根","keywords":"","body":"5.09 T69.x的平方根 [toc] 题目 实现 int sqrt(int x) 函数。 计算并返回 x 的平方根，其中 x 是非负整数。 由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。 示例 1: 输入: 4 输出: 2 示例 2: 输入: 8 输出: 2 说明: 8 的平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/sqrtx 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解 二分 class Solution: def mySqrt(self, x: int) -> int: left, right = 1, x while left>1 if mid**2>x: right = mid-1 elif mid**2 执行用时:64 ms, 在所有 Python3 提交中击败了29.70%的用户 内存消耗:13.6 MB, 在所有 Python3 提交中击败了6.06%的用户 题解2 牛顿迭代，使用切线， $f(x) = x^2 - C$ ，在$(x_0, f(x_0))$处的切线与x轴的交点越来越接近零点。 class Solution: def mySqrt(self, x: int) -> int: if x==0: return 0 C = float(x) x0 = float(x) while True: x1 = (x0 + C/x0)/2 if abs(x1-x0) 执行用时 :48 ms, 在所有 Python3 提交中击败了64.24%的用户 内存消耗 :13.7 MB, 在所有 Python3 提交中击败了6.06%的用户 Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-05-09 12:28:38 "},"leetcode/2020_05月/5.10二叉树的最近公共祖先.html":{"url":"leetcode/2020_05月/5.10二叉树的最近公共祖先.html","title":"5.10 T236.二叉树的最近公共祖先","keywords":"","body":"5.10 T236.二叉树的最近公共祖先 题目 给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 例如，给定如下二叉树: root = [3,5,1,6,2,0,8,null,null,7,4] 示例 1: 输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1 输出: 3 解释: 节点 5 和节点 1 的最近公共祖先是节点 3。 示例 2: 输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4 输出: 5 解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。 说明: 所有节点的值都是唯一的。 p、q 为不同节点且均存在于给定的二叉树中。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解1 中序遍历，若节点p和q在两边或者最近公共节点是自身的情况。 # Definition for a binary tree node. # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution: def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode': self.res = None def inorder(root): if not root: return [] orderlist = [] left = inorder(root.left) right = inorder(root.right) tmp = left + right if (p.val in left and q.val in right) or (p.val in right and q.val in left) or (p.val==root.val and q.val in tmp) or (q.val== root.val and p.val in tmp): if self.res==None: self.res = root orderlist.extend(left) orderlist.append(root.val) orderlist.extend(right) return orderlist inorder(root) return self.res 执行用时992ms，list的操作耗时。 题解2 对题解1进行改进，遍历时直接返回是否在其子树中。 class Solution: def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode': self.res = None def dfs(root): if not root: return False left = dfs(root.left) right = dfs(root.right) if (left and right) or ((root.val==p.val or root.val==q.val) and (left or right)): self.res = root return left or right or root.val==p.val or root.val== q.val dfs(root) return self.res 执行时间92ms，超过56.30%的python3提交记录。 时间复杂度$O(n)$，空间复杂度$O(n)$。 题解3 遍历一次树，用字典以孩子节点: 父节点的键值对形式存储下来。 从q节点通过字典一直向上查找，并用一个数组标记已访问。 再从p节点向上访问，当访问到第一个已访问的节点时，该节点就是q和p的最近公共祖先节点。 时间复杂度$O(n)$，空间复杂度$O(n)$。 Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-05-10 21:23:36 "},"leetcode/2020_05月/5.11Pow.html":{"url":"leetcode/2020_05月/5.11Pow.html","title":"5.11 T50.Pow(x, n)","keywords":"","body":"5.11 T50.Pow(x, n) 题目 实现 pow(x, n) ，即计算 x 的 n 次幂函数。 示例 1: 输入: 2.00000, 10 输出: 1024.00000 示例 2: 输入: 2.10000, 3 输出: 9.26100 示例 3: 输入: 2.00000, -2 输出: 0.25000 解释: 2-2 = 1/22 = 1/4 = 0.25 说明: -100.0 n 是 32 位有符号整数，其数值范围是 [−231, 231 − 1] 。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/powx-n 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解1 将幂转换为二进制数考虑，如$x^{10}$，10的二进制为1010，则$x^{10} = x^{2^3} * x^{2^2}$ class Solution: def myPow(self, x: float, n: int) -> float: if n==0: return 1 a = x if n>0 else 1/x b = abs(n) res = 1.0 while b>0: if b&1: res *= a a *= a b = b//2 return res 是否应该考虑数越界问题，使用异常捕获？ Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-05-11 09:56:34 "},"leetcode/2020_05月/5.12最小栈.html":{"url":"leetcode/2020_05月/5.12最小栈.html","title":"5.12 T155.最小栈","keywords":"","body":"5.12 T155.最小栈 题目 设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。 push(x) —— 将元素 x 推入栈中。 pop() —— 删除栈顶的元素。 top() —— 获取栈顶元素。 getMin() —— 检索栈中的最小元素。 示例: 输入： [\"MinStack\",\"push\",\"push\",\"push\",\"getMin\",\"pop\",\"top\",\"getMin\"] [[],[-2],[0],[-3],[],[],[],[]] 输出： [null,null,null,null,-3,null,0,-2] 解释： MinStack minStack = new MinStack(); minStack.push(-2); minStack.push(0); minStack.push(-3); minStack.getMin(); --> 返回 -3. minStack.pop(); minStack.top(); --> 返回 0. minStack.getMin(); --> 返回 -2. 提示： pop、top 和 getMin 操作总是在 非空栈 上调用。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/min-stack 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解 用两个list，一个用作普通栈，一个用作存储最小元素栈。 关键操作： 当x入栈时，小于等于当前栈最小元素就入minlist栈。 当出栈时，若出栈元素x等于当前栈最小元素时（x == minlist[-1]），最小栈也出栈。 class MinStack: def __init__(self): \"\"\" initialize your data structure here. \"\"\" self.stack = [] self.minlist = [] def push(self, x: int) -> None: self.stack.append(x) if not self.minlist or x None: x = self.stack.pop() if self.minlist and self.minlist[-1]==x: self.minlist.pop() def top(self) -> int: return self.stack[-1] def getMin(self) -> int: return self.minlist[-1] # Your MinStack object will be instantiated and called as such: # obj = MinStack() # obj.push(x) # obj.pop() # param_3 = obj.top() # param_4 = obj.getMin() 时间复杂度$O(1)$，空间复杂度$O(n)$。 Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-05-12 09:22:50 "},"leetcode/2020_05月/5.13二叉树的层序遍历.html":{"url":"leetcode/2020_05月/5.13二叉树的层序遍历.html","title":"5.13 T102.二叉树的层序遍历","keywords":"","body":"5.13 T102.二叉树的层序遍历 题目 给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。 示例： 二叉树：[3,9,20,null,null,15,7], 3 / \\ 9 20 / \\ 15 7 返回其层次遍历结果： [ [3], [9,20], [15,7] ] 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/binary-tree-level-order-traversal 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解1 普通的层次遍历，只不过把每层的节点单独作为一个列表。使用一个变量存储每层的节点数，当其为0时则表示将进入下一层。 # Definition for a binary tree node. # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.right = None import collections class Solution: def levelOrder(self, root: TreeNode) -> List[List[int]]: if not root: return [] res = [] queue = collections.deque() queue.append(root) cnt = 1 # 每层节点数 cen = [] # 每层存储的列表 while queue: node = queue.popleft() cen.append(node.val) cnt -= 1 if node.left: queue.append(node.left) if node.right: queue.append(node.right) # 该层结束，重置下一层 if cnt==0: res.append(cen) cnt = len(queue) cen = [] return res Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-05-13 09:04:29 "},"leetcode/2020_05月/5.14只出现一次的数字.html":{"url":"leetcode/2020_05月/5.14只出现一次的数字.html","title":"5.14 T136.只出现一次的数字","keywords":"","body":"5.14 T136.只出现一次的数字 题目 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。 说明： 你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？ 示例 1: 输入: [2,2,1] 输出: 1 示例 2: 输入: [4,1,2,1,2] 输出: 4 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/single-number 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解1 异或操作，因为数组中只有一个数出现一次，其余都只出现两次。而且两个相同的数异或为0，任何数与0异或都为其自身。 class Solution: def singleNumber(self, nums: List[int]) -> int: res = 0 for i in nums: res ^= i return res 时间复杂度$O(n)$，空间复杂度$O(1)$。 Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-05-14 10:16:29 "},"leetcode/2020_05月/5.15和为K的子数组.html":{"url":"leetcode/2020_05月/5.15和为K的子数组.html","title":"5.15 T560.和为K的子数组","keywords":"","body":"5.15 T560.和为K的子数组 题目 给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。 示例 1 : 输入:nums = [1,1,1], k = 2 输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。 说明 : 数组的长度为 [1, 20,000]。 数组中元素的范围是 [-1000, 1000] ，且整数 k 的范围是 [-1e7, 1e7]。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/subarray-sum-equals-k 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解1 暴力，枚举所有可能区间。 class Solution: def subarraySum(self, nums: List[int], k: int) -> int: cnt = 0 n = len(nums) for i in range(n): tmp = 0 for j in range(i, n): tmp += nums[j] if tmp==k: cnt += 1 return cnt 时间复杂度$O(n^2)$，空间复杂度$O(1)$。超时 题解2 前缀和 + 哈希表 遍历一次数组nums，每次遍历到nums[i]时存储nums[0:i+1]的和。目标是找到一个0，使得nums[j:i+1]的和等于k。 那么建立字典，以前缀数组和为键，出现次数为值。 又每次只使用nums[0:i+1]的和，所以可以使用一个变量存储，每次自增更新。 class Solution: def subarraySum(self, nums: List[int], k: int) -> int: cnt = 0 n = len(nums) meno = {0:1} tmp = 0 for i in range(n): tmp += nums[i] # 先计算，再更新（防止k==0时，把自己多算了一次） if tmp-k in meno: cnt += meno[tmp-k] if tmp not in meno: meno[tmp] = 1 else: meno[tmp] += 1 return cntn 时间复杂度$O(n)$，空间复杂度$O(n)$。 Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-05-15 10:30:11 "},"leetcode/2020_05月/5.16K个一组翻转链表.html":{"url":"leetcode/2020_05月/5.16K个一组翻转链表.html","title":"5.16 T25.K个一组翻转链表","keywords":"","body":"5.16 T25.K个一组翻转链表 题目 给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。 k 是一个正整数，它的值小于或等于链表的长度。 如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。 示例： 给你这个链表：1->2->3->4->5 当 k = 2 时，应当返回: 2->1->4->3->5 当 k = 3 时，应当返回: 3->2->1->4->5 说明： 你的算法只能使用常数的额外空间。 你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/reverse-nodes-in-k-group 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解1 每次判断该节点之后是否有k个节点翻转，若为True则翻转，否则原样返回。 再对反转链表进行链接。 # Definition for singly-linked list. # class ListNode: # def __init__(self, x): # self.val = x # self.next = None class Solution: def reverseKGroup(self, head: ListNode, k: int) -> ListNode: if not head: return head def isK(node, k): cnt = 0 cur = node while cur: cur = cur.next; cnt += 1 if cnt==k: break return cnt==k cur = head tail, left, right = None, None, None res = None while isK(cur, k): # print(f'{cur.val}\\t{k}') cnt = 1 left, right = cur, cur.next while cnt 题解2 每次前进k次，并翻转。若最后一次翻转没有k个，则再重新翻转回复之前的链表。 遍历中，对每一段k个节点翻转后，进行链接。 class Solution: def reverseKGroup(self, head: ListNode, k: int) -> ListNode: def reverseK(head): if not head: return None, None, None, False tail = head a, b = head, head.next a.next = None # 截断链表，防止最后再次翻转中进入无限循环链表 cnt = 1 while cnt Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-05-16 10:17:25 "},"leetcode/2020_05月/5.17课程表II.html":{"url":"leetcode/2020_05月/5.17课程表II.html","title":"5.17 T210.课程表II","keywords":"","body":"5.17 T210.课程表II 题目 现在你总共有 n 门课需要选，记为 0 到 n-1。 在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1]。 给定课程总量以及它们的先决条件，返回你为了学完所有课程所安排的学习顺序。 可能会有多个正确的顺序，你只要返回一种就可以了。如果不可能完成所有课程，返回一个空数组。 示例 1: 输入: 2, [[1,0]] 输出: [0,1] 解释: 总共有 2 门课程。要学习课程 1，你需要先完成课程 0。因此，正确的课程顺序为 [0,1] 。 示例 2: 输入: 4, [[1,0],[2,0],[3,1],[3,2]] 输出: [0,1,2,3] or [0,2,1,3] 解释: 总共有 4 门课程。要学习课程 3，你应该先完成课程 1 和课程 2。并且课程 1 和课程 2 都应该排在课程 0 之后。 因此，一个正确的课程顺序是 [0,1,2,3] 。另一个正确的排序是 [0,2,1,3] 。 说明: 输入的先决条件是由边缘列表表示的图形，而不是邻接矩阵。详情请参见图的表示法。 你可以假定输入的先决条件中没有重复的边。 提示: 这个问题相当于查找一个循环是否存在于有向图中。如果存在循环，则不存在拓扑排序，因此不可能选取所有课程进行学习。 通过 DFS 进行拓扑排序 - 一个关于Coursera的精彩视频教程（21分钟），介绍拓扑排序的基本概念。 拓扑排序也可以通过 BFS 完成。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/course-schedule-ii 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解1 对一个图进行拓扑排序，通过一个数组记录每个节点的入度。 对所有未遍历的入度为0的节点，遍历（加入结果中）。并将其连接到的点的入度减1。 重复上述操作，直至未遍历点中，没有入度为0的点。 此时，若结果中点数比总节点数少，则说明该图有环。 class Solution: def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]: if not prerequisites: return list(range(numCourses)) graph = {} # 存储有向图的边 n = numCourses indegree = [0]*n # 入度数组 node = set(range(n)) # 未遍历节点集合 for a, b in prerequisites: indegree[a] += 1 if b not in graph: graph[b] = [a] else: graph[b].append(a) res = [] cnt = 0 while cnt 题解2 对上述方法进行改进，用一个队列存储入度为0的节点，然后依次退队，访问。 import collections class Solution: def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]: # 存储有向图 edges = collections.defaultdict(list) # 存储每个节点的入度 indeg = [0] * numCourses # 存储答案 result = list() for info in prerequisites: edges[info[1]].append(info[0]) indeg[info[0]] += 1 # 将所有入度为 0 的节点放入队列中 q = collections.deque([u for u in range(numCourses) if indeg[u] == 0]) while q: # 从队首取出一个节点 u = q.popleft() # 放入答案中 result.append(u) for v in edges[u]: indeg[v] -= 1 # 如果相邻节点 v 的入度为 0，就可以选 v 对应的课程了 if indeg[v] == 0: q.append(v) if len(result) != numCourses: result = list() return result # 作者：LeetCode-Solution # 链接：https://leetcode-cn.com/problems/course-schedule-ii/solution/ke-cheng-biao-ii-by-leetcode-solution/ # 来源：力扣（LeetCode） # 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 时间复杂度$O(n+m)$，其中n为课程数，m为先修课程的要求数。这其实就是对图进行广度优先搜索的时间复杂度。 空间复杂度$O(n+m)$。 Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-05-17 10:25:01 "},"leetcode/2020_05月/5.18乘积最大子数组.html":{"url":"leetcode/2020_05月/5.18乘积最大子数组.html","title":"5.18 T152.乘积最大子数组","keywords":"","body":"5.18 T152.乘积最大子数组 题目 给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。 示例 1: 输入: [2,3,-2,4] 输出: 6 解释: 子数组 [2,3] 有最大乘积 6。 示例 2: 输入: [-2,0,-1] 输出: 0 解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/maximum-product-subarray 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解1 因为列表存储的是整数，所以若忽略符号影响，则相乘之后不会减小。关键在于0和负数。 如果列表全为正数，则结果就是所有数相乘 如果列表为正数和0，则0将列表划分为几部分，乘积最大子数组为各部分乘积的最大值。 如果列表中有负数，则考虑连续偶数（负负得正）个负数乘积 偶数个负数，直接全乘就是最大值 奇数个负数，则舍弃一个负数（得到剩余偶数个负数相乘正数相乘），取 舍弃第一个负数 与 舍弃最后一个负数 的较大值。例如[2, -2, -3, -4, 2]，三个负数，则舍弃第一个负数得[-3, -4, 2]或舍弃最后一个负数[2, -2, -3] 代码整的挺烂 class Solution: def maxProduct(self, nums: List[int]) -> int: if not nums: return 0 is0 = False a = 0 # 存储遇到第一个负数的累乘 res = None tmp = 1 for i in nums: if i==0: if res==None: res = 0 tmp = 1 a = 0 is0 = True continue tmp *= i res = max(res, tmp) if res!=None else tmp if a!=0: res = max(res, tmp//a) if i 题解2 动态规划 $f_{max}(i)$存储以nums[i]结尾的子数组乘积最大值。 当数组没有负数时，$f{max}(i) = max(f{max}(i-1)*nums[i], nums[i])$ 有负数，例[-2, 5, -2]按照状态定义$f_{max}$应该为[-2, 5, 20]，但是若按递推公式来为[-2, 5, -2]，不同。关键在于负负得正。 参考leetcode题解，我们可以根据正负性进行分类讨论。 考虑当前位置如果是一个负数的话，那么我们希望以它前一个位置结尾的某个段的积也是个负数，这样就可以负负得正，并且我们希望这个积尽可能「负得更多」，即尽可能小。如果当前位置是一个正数的话，我们更希望以它前一个位置结尾的某个段的积也是个正数，并且希望它尽可能地大。于是这里我们可以再维护一个$f_{\\min}(i)$，它表示以nums[i]结尾的乘积最小子数组的乘积，那么我们可以得到这样的动态规划转移方程： fmax(i)=max(fmax(i−1)∗nums[i], fmin(i−1)∗nums[i], nums[i]) f_{max}(i) = max(f_{max}(i-1)*nums[i], \\ f_{min}(i-1)*nums[i], \\ nums[i]) f​max​​(i)=max(f​max​​(i−1)∗nums[i], f​min​​(i−1)∗nums[i], nums[i]) fmin(i)=min(fmax(i−1)∗nums[i], fmin(i−1)∗nums[i], nums[i]) f_{min}(i) = min(f_{max}(i-1)*nums[i], \\ f_{min}(i-1)*nums[i], \\ nums[i]) f​min​​(i)=min(f​max​​(i−1)∗nums[i], f​min​​(i−1)∗nums[i], nums[i]) 作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/maximum-product-subarray/solution/cheng-ji-zui-da-zi-shu-zu-by-leetcode-solution/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 官方C++代码如下： class Solution { public: int maxProduct(vector& nums) { vector maxF(nums), minF(nums); for (int i = 1; i & nums) { int maxF = nums[0], minF = nums[0], ans = nums[0]; for (int i = 1; i Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2021-03-02 18:37:01 "},"leetcode/2020_05月/5.19验证回文字符串Ⅱ.html":{"url":"leetcode/2020_05月/5.19验证回文字符串Ⅱ.html","title":"5.19 T680.验证回文字符串Ⅱ","keywords":"","body":"5.19 T680.验证回文字符串Ⅱ 题目 给定一个非空字符串s，最多删除一个字符。判断是否能成为回文字符串。 示例 1: 输入: \"aba\" 输出: True 示例 2: 输入: \"abca\" 输出: True 解释: 你可以删除c字符。 注意: 字符串只包含从 a-z 的小写字母。字符串的最大长度是50000。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/valid-palindrome-ii 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解1 分两种情况： 该串本身就是回文串，直接返回True 该串不是回文串，使用双指针从左端和右端往中间检测，直至s[left]!=s[right] 检测s[left:right]（舍弃右端点），是否是回文串 检测s[left+1:right+1（舍弃左端点），是否是回文串 若两部分中只要有一个能成为回文串，则返回True，否则不能通过删除一个字符使其成为回文串。 class Solution: def validPalindrome(self, s: str) -> bool: def isPalindrome(s): k = len(s)>>1 return s[: k] == s[-1: -1-k: -1] if isPalindrome(s): return True left, right = 0, len(s)-1 while left Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-05-19 10:26:32 "},"leetcode/2020_05月/5.20每个元音包含偶数次的最长子字符串.html":{"url":"leetcode/2020_05月/5.20每个元音包含偶数次的最长子字符串.html","title":"5.20 T1371.每个元音包含偶数次的最长子字符串","keywords":"","body":"5.20 T1371.每个元音包含偶数次的最长子字符串 题目 给你一个字符串 s ，请你返回满足以下条件的最长子字符串的长度：每个元音字母，即 'a'，'e'，'i'，'o'，'u' ，在子字符串中都恰好出现了偶数次。 示例 1： 输入：s = \"eleetminicoworoep\" 输出：13 解释：最长子字符串是 \"leetminicowor\" ，它包含 e，i，o 各 2 个，以及 0 个 a，u 。 示例 2： 输入：s = \"leetcodeisgreat\" 输出：5 解释：最长子字符串是 \"leetc\" ，其中包含 2 个 e 。 示例 3： 输入：s = \"bcbcbc\" 输出：6 解释：这个示例中，字符串 \"bcbcbc\" 本身就是最长的，因为所有的元音 a，e，i，o，u 都出现了 0 次。 提示： $1 s只包含小写英文字母。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/find-the-longest-substring-containing-vowels-in-even-counts 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解1 暴力，枚举所有可能的子串，统计元音字母频数，更新满足条件的子串最大长度。（超时，s的长度达到$10^5$） 统计元音字母频数，可以使用前缀数组。pre[i]存储s前i个字母构成子串的元音频数。那么计算子串元音频数可通过pre[i]-pre[j]。即使如此，时间复杂度还是$O(n^2)$，超时。 题解2 对题解1进行优化，回忆之前有一题1248. 统计「优美子数组」是计算\"优美子数组\"个数（连续子数组中恰有k个奇数则称为\"优美子数组\"），因为k固定，所以当使用前缀和pre[i]表示前i个字符奇数个数时，可以直接利用哈希，取pre[i]-k在$O(1)$时间取出满足条件的连续子数组。 同样本题，要求是连续子串元音频数为偶数。又知，两数只有奇偶性相同时差才为偶数，所以我们使用一个状态表示前i个字符的每个元音奇偶性。 奇为1，偶为0，一共5个元音，按二进制组合最大11111，最小00000，所以使用一个长度32的数组存储奇偶信息。 indlist[i]存储奇偶信息对应为i的，最小索引值。 from functools import reduce class Solution: def findTheLongestSubstring(self, s: str) -> int: res = 0 n = len(s) word = 'aeiou' meno = {} indlist = [n]*32 indlist[0] = -1 for i in word: meno[i] = 0 for i in range(n): if s[i] in word: meno[s[i]] += 1 meno[s[i]] %= 2 # 计算奇偶状态组成二进制数值 tmp = reduce(lambda x, y: x+str(y), meno.values(), '') ind = int(tmp, 2) if indlist[ind]!=n: res = max(res, i-indlist[ind]) indlist[ind] = min(indlist[ind], i) return res 因为使用了functools.reduce()通过字符串相加计算二进制，所以最后提交运行时间有点慢，超过5%python3玩家。 时间复杂度$O(n)$，空间复杂度$O(S)$。S是状态数，本题为32。 原理不变，改进算法实现，利用位运算，取消字符串相加和int(s, 2)。 class Solution: def findTheLongestSubstring(self, s: str) -> int: res = 0 n = len(s) word = 'aeiou' meno = {} for i, c in enumerate(word): meno[c] = 1 Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-05-20 11:29:58 "},"leetcode/2020_05月/5.21最长回文子串.html":{"url":"leetcode/2020_05月/5.21最长回文子串.html","title":"5.21 T5.最长回文子串","keywords":"","body":"5.21 T5.最长回文子串 题目 给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。 示例 1： 输入: \"babad\" 输出: \"bab\" 注意: \"aba\" 也是一个有效答案。 示例 2： 输入: \"cbbd\" 输出: \"bb\" 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/longest-palindromic-substring 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解1 暴力，枚举所有的可能回文串中心，向两边延申。 考虑当回文串字符数为奇数时，中心为字符；当字符数为偶数时，中心为空。要分情况，麻烦，这里对字符串进行操作，使用'#'号隔开每个字符，使整个字符串字符数变为奇数个。 例如：babad变为#b#a#b#a#d#，倘若索引ind时最长半径r，则最长回文子串为s[ind-r+1: ind+r: 2] class Solution: def longestPalindrome(self, s: str) -> str: if not s: return '' arr = '#' + '#'.join(list(s)) + '#' n = len(arr) MaxC = 0 MaxR = 0 for i in range(n): r = 1 while i-r>=0 and i+rMaxR: MaxR = r MaxC = i # print(MaxC, MaxR) return arr[MaxC-MaxR+1: MaxC+MaxR: 2] 执行时间2244ms，超过57.78%python3用户。 时间复杂度$O(n^2)$，空间复杂度$O(1)$。 题解2 Manacher算法，核心思想：维护一个半径数组，和最右边界，最长回文子串就为半径数组中最大的值和对应半径构成的子串。该算法充分利用了已匹配的字符信息。 当当前判断的字符在最右边界内，则计算关于中心的镜像点 获取镜像及最右边界约束的半径，然后继续向两边延申判断回文 当延申超过最右边界时，更新最右边界和对应的中心 如果当前计算的半径较大，则更新最终结果的中心点 Manacher算法参考博客 Manacher 马拉车算法 class Solution: def longestPalindrome(self, s: str) -> str: if not s: return '' arr = '^#' + '#'.join(list(s)) + '#$' radius_list = [0]*len(arr) iMaxCenter = 0 iCenter = 0 iRight = 0 for i in range(1, len(arr)-1): if i>len(arr)-radius_list[iMaxCenter]-1: break if iiRight: iRight = i + radius_list[i] iCenter = i if radius_list[i]>radius_list[iMaxCenter]: iMaxCenter = i # print(f'{radius_list}\\niMaxCenter = {iMaxCenter}') start = (iMaxCenter-radius_list[iMaxCenter])//2 return s[start:start+radius_list[iMaxCenter]] 执行时间84ms，战胜97.74%python3用户。 时间复杂度$O(n)$，空间复杂度$O(n)$。 Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-05-22 15:41:34 "},"leetcode/2020_05月/5.22从前序与中序遍历序列构造二叉树.html":{"url":"leetcode/2020_05月/5.22从前序与中序遍历序列构造二叉树.html","title":"5.22 T105.从前序与中序遍历序列构造二叉树","keywords":"","body":"5.22 T105.从前序与中序遍历序列构造二叉树 题目 根据一棵树的前序遍历与中序遍历构造二叉树。 注意: 你可以假设树中没有重复的元素。 例如，给出 前序遍历 preorder = [3,9,20,15,7] 中序遍历 inorder = [9,3,15,20,7] 返回如下的二叉树： 3 / \\ 9 20 / \\ 15 7 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解1 递归，利用中序遍历和前序遍历的特点。 中序遍历顺序：左子树 + 根 + 右子树 前序遍历顺序：根 + 左子树 + 右子树 递归思路： 前序遍历结果第一个肯定是根，建立根节点。 在中序遍历结果中找到这个根，将树分为左子树的中序、右子树的中序。 根据左子树节点个数，将前序遍历结果也可划分为左子树的前序、右子树的前序。 递归对左右子树进行建树。 # Definition for a binary tree node. # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution: def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode: def build(preorder, inorder): if not preorder: return None a = preorder[0] ind = inorder.index(a) root = TreeNode(a) leftchild = build(preorder[1:ind+1], inorder[:ind]) rightchild = build(preorder[ind+1:], inorder[ind+1:]) root.left = leftchild root.right = rightchild return root res = build(preorder, inorder) return res 时间复杂度$O(n)$。 Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-05-22 15:47:25 "},"leetcode/2020_05月/5.23最小覆盖子串.html":{"url":"leetcode/2020_05月/5.23最小覆盖子串.html","title":"5.23 T76.最小覆盖子串","keywords":"","body":"5.22 T76.最小覆盖子串 题目 给你一个字符串 S、一个字符串 T，请在字符串 S 里面找出：包含 T 所有字符的最小子串。 示例： 输入: S = \"ADOBECODEBANC\", T = \"ABC\" 输出: \"BANC\" 说明： 如果 S 中不存这样的子串，则返回空字符串 \"\"。 如果 S 中存在这样的子串，我们保证它是唯一的答案。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/minimum-window-substring 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解1 原理： 核心是暴力法 若有解，结果第一个字符和最后一个字符一定是匹配的。 该方法就是对暴力实现进行了一点实现上的优化，但时间复杂度依旧是$O(mn)$。最后一个案例过不了，超时。 import collections class Solution: def minWindow(self, s: str, t: str) -> str: queue = collections.deque() res = (0,len(s)+1) cnt = 0 meno = collections.defaultdict(int) for i in t: meno[i] += 1 for i in range(len(s)): if s[i] in meno: queue.append(i) # print(meno) # print(queue) while queue: cnt = 0 tmpmeno = collections.defaultdict(int) left = queue[0] for i in queue: if tmpmeno[s[i]]i+1-left: res = (left, i+1) break else: break queue.popleft() if res[1]==len(s)+1: return '' return s[res[0]: res[1]] 题解2 滑动窗口，AC，时间复杂度$O(n)$。 left，right控制窗口边界。 依次前进right，统计覆盖t的频数。 若覆盖t，则更新结果。并右移left不断更新，直至覆盖不了t。 重复上述两步，直至right到达字符串s的末尾，右移left至窗口覆盖不了t时结束循环。 import collections class Solution: def minWindow(self, s: str, t: str) -> str: if len(s)right-left: res = (left, right) if s[left] in meno: tmpmeno[s[left]] -= 1 if tmpmeno[s[left]] Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-05-24 10:03:05 "},"leetcode/2020_05月/5.24寻找两个正序数组的中位数.html":{"url":"leetcode/2020_05月/5.24寻找两个正序数组的中位数.html","title":"5.24 T4.寻找两个正序数组的中位数","keywords":"","body":"5.24 T4.寻找两个正序数组的中位数 题目 给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。 请你找出这两个正序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。 你可以假设 nums1 和 nums2 不会同时为空。 示例 1: nums1 = [1, 3] nums2 = [2] 则中位数是 2.0 示例 2: nums1 = [1, 2] nums2 = [3, 4] 则中位数是 (2 + 3)/2 = 2.5 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/median-of-two-sorted-arrays 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解1 归并排序，依次比较合并两个有序数组，然后返回索引(m+n)//2; (m+n)//2-1, (if (m+n)&1==0)。时间复杂度$O(m+n)$ 题目要求中位数，不用真的将数组归并。可以使用两个指针分别指向两个数组，初始p = 0; q = 0。 比较nums1[p]和nums2[q]大小，小的指针往后进一步，当淘汰一半的数时，就找到中位数了。时间复杂度$O(\\frac{m+n}{2}) = O(m+n)$ 题解2 由中位数的性质，结合二分，对题解1中的指针法进行改进。 设数组A、B，每次选第k//2个比较，值较小的那组前k//2舍弃，更新k值。k = (m+n+1)//2 指针p=k//2; q=k//2。若A[p]，则A[:p]不可能是中位数 class Solution: def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float: m, n = len(nums1), len(nums2) A, B = nums1, nums2 if m > n: A, B, m, n = nums2, nums1, n, m if n == 0: raise ValueError('null') k = (m+n+1)//2 left1, left2 = -1, -1 while k>0: if k>1: p1 = p2 = k//2 else: p1 = p2 = 1 if left1!=m-1 and left1+p1>=m: p1 = m-left1-1 if left2 != n-1 and left2+p2>=n: p2 = n-left2-1 if left1 == m-1: left2 += k k = 0 break if -1 时间复杂度$O(\\log(m+n))$ 题解3 对数组进行划分，由中位数性质，枚举较小长度数组索引。 left_A | right_A A[0], A[1], ..., A[i-1] | A[i], A[i+1], ..., A[m-1] left_B | right_B B[0], B[1], ..., B[j-1] | B[j], B[j+1], ..., B[n-1] left_part | right_part A[0], A[1], ..., A[i-1] | A[i], A[i+1], ..., A[m-1] B[0], B[1], ..., B[j-1] | B[j], B[j+1], ..., B[n-1] 作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/xun-zhao-liang-ge-you-xu-shu-zu-de-zhong-wei-s-114/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 class Solution: def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float: m, n = len(nums1), len(nums2) A, B = nums1, nums2 if m>n: A, B, m, n = nums2, nums1, n, m if n==0: raise ValueError('null') imin, imax, k = 0, m, (m+n+1)//2 while imin0 and jB[j]: imax = i-1 elif j>0 and i 时间复杂度$O(\\log(\\min(m, n)))$ Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-05-24 15:26:17 "},"leetcode/2020_05月/5.25LRU缓存机制.html":{"url":"leetcode/2020_05月/5.25LRU缓存机制.html","title":"5.25 T146.LRU缓存机制","keywords":"","body":"5.25 T146.LRU缓存机制 题目 请你为 最不经常使用（LFU）缓存算法设计并实现数据结构。它应该支持以下操作：get 和 put。 get(key) - 如果键存在于缓存中，则获取键的值（总是正数），否则返回 -1。 put(key, value) - 如果键已存在，则变更其值；如果键不存在，请插入键值对。当缓存达到其容量时，则应该在插入新项之前，使最不经常使用的项无效。在此问题中，当存在平局（即两个或更多个键具有相同使用频率）时，应该去除最久未使用的键。 [项的使用次数]就是自插入该项以来对其调用 get 和 put 函数的次数之和。使用次数会在对应项被移除后置为 0 。 进阶： 你是否可以在 O(1) 时间复杂度内执行两项操作？ 示例： LFUCache cache = new LFUCache( 2 /* capacity (缓存容量) */ ); cache.put(1, 1); cache.put(2, 2); cache.get(1); // 返回 1 cache.put(3, 3); // 去除 key 2 cache.get(2); // 返回 -1 (未找到key 2) cache.get(3); // 返回 3 cache.put(4, 4); // 去除 key 1 cache.get(1); // 返回 -1 (未找到 key 1) cache.get(3); // 返回 3 cache.get(4); // 返回 4 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/lfu-cache 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解1 哈希表：在$O(1)$时间内实现get，put 双向链表：在$O(1)$时间内实现节点移动（将节点按使用顺序排成链表） 在Python语言中，有一种结合了哈希表与双向链表的数据结构OrderedDict。 class LRUCache(collections.OrderedDict): def __init__(self, capacity: int): super().__init__() self.capacity = capacity def get(self, key: int) -> int: if key not in self: return -1 self.move_to_end(key) return self[key] def put(self, key: int, value: int) -> None: if key in self: self.move_to_end(key) self[key] = value if len(self) > self.capacity: self.popitem(last=False) # 作者：LeetCode-Solution # 链接：https://leetcode-cn.com/problems/lru-cache/solution/lruhuan-cun-ji-zhi-by-leetcode-solution/ # 来源：力扣（LeetCode） # 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 题解2 自己手动实现双向链表 # 双向链表节点 class Node: def __init__(self, val=0): self.val = val self.next = None self.pre = None class LRUCache: def __init__(self, capacity: int): # 存储缓存，键key，值value self.Cache = {} # 建立一个头节点方便操作 self.head = Node() self.tail = self.head # 存储节点方便修改链表，键key，值Node节点 self.meno = {} # 当前缓存个数 self.length = 0 self.capacity = capacity def get(self, key: int) -> int: if key in self.Cache: node = self.meno[key] # 如果不是尾节点，就将该节点移到链表尾部（尾部意味着最新使用） if node!=self.tail: node.pre.next = node.next node.next.pre = node.pre self.tail.next = node node.pre = self.tail self.tail = node # print(self.Cache[key]) return self.Cache[key] # print(-1) return -1 def put(self, key: int, value: int) -> None: if key in self.Cache: # 更新链表节点的位置 self.get(key) # 更新对应值 self.Cache[key] = value else: # 新建节点，节点存储key（因为要通过退出节点获取，要删除缓存中的键key） node = Node(key) # 将节点加入到链表尾部 self.tail.next = node node.pre = self.tail self.tail = node # 更新缓存和存储节点的表 self.Cache[key] = value self.meno[key] = node # 如果长度到达容量，就前进链表头节点，删除最不常用的key if self.length == self.capacity: self.head = self.head.next tmpkey = self.head.val self.Cache.pop(tmpkey) self.meno.pop(tmpkey) else: self.length += 1 改进方案： Node(key, value)可以将key, value都存入。 self.Cache = {}直接存节点（避免用Cache, meno两个哈希表） Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-05-25 10:21:13 "},"leetcode/2020_05月/5.26寻找重复数.html":{"url":"leetcode/2020_05月/5.26寻找重复数.html","title":"5.26 T287.寻找重复数","keywords":"","body":"5.26 T287.寻找重复数 题目 给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。 示例 1: 输入: [1,3,4,2,2] 输出: 2 示例 2: 输入: [3,1,3,4,2] 输出: 3 说明： 不能更改原数组（假设数组是只读的）。 只能使用额外的 O(1) 的空间。 时间复杂度小于 O(n2) 。 数组中只有一个重复的数字，但它可能不止重复出现一次。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/find-the-duplicate-number 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解1 找到有序数组，二分查找。 构造数组cnts[k]，表示在nums中小于等于k的个数。设重复数为target，则1 。 当k时，cnts[k] 当k>=target时，cnts[k]>k 由此得到数组cnts是递增的，可用二分法。由于题目要求空间复杂度$O(1)$，所以每次在循环中手动计算cnts[k]。 class Solution: def findDuplicate(self, nums: List[int]) -> int: res = 0 n = len(nums)-1 left, right = 1, n while left>1 cnt = 0 for i in nums: if imid: right = mid elif cnt 时间复杂度$O(n\\log(n))$。 题解2 利用二进制。 题目数组nums有n+1个数，每个数的范围为[1, n]。所以重复数target，相当于用target去替换其他数。 将[1, n]范围内每个数转为二进制，并统计[0, math.log(n, 2)]每一位1的个数。 以样例二[3,1,3,4,2]说明 1 001 1 001 2 010 2 010 3 011 3 011 3 011 4 100 4 100 133 122 最后一行是统计第k位1的个数（$k \\in [0, \\log{n}]$） 当target去替换其他数时，只有相同位上1个数会增加。所以统计所有1增加对应的位数，形成的二进制数就是target。 import math class Solution: def findDuplicate(self, nums: List[int]) -> int: res = 0 n = len(nums)-1 if n>i)&1 for j in nums: y_cnt += (j>>i)&1 if y_cnt>x_cnt: res += 1 时间复杂度$O(n\\log(n))$，空间复杂度$O(1)$。 题解3 利用图的知识。数组nums[i]中，索引i为边的起点，值nums[i]作为边的终点，构造一个有向图。 由0得：图中有n+1个节点，n条边。且至少有两条边的终点都是target节点；每个节点出度都为1，除去target和0其余节点入度为1。 0节点：入度为0，出度为1 target节点：入度为重复次数>=2，出度为1 其余节点：入度为1，出度为1 所以必定可以形成环。否则形成的链表尾节点的出度就为0，矛盾。 且从0出发形成的环，起点就是target节点。 class Solution: def findDuplicate(self, nums: List[int]) -> int: if len(nums) 时间复杂度$O(n)$，空间复杂度$O(1)$。 Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-05-26 11:05:32 "},"leetcode/2020_05月/5.27和可被K整除的子数组.html":{"url":"leetcode/2020_05月/5.27和可被K整除的子数组.html","title":"5.27 T974.和可被K整除的子数组","keywords":"","body":"5.27 T974.和可被K整除的子数组 题目 给定一个整数数组 A，返回其中元素之和可被 K 整除的（连续、非空）子数组的数目。 示例： 输入：A = [4,5,0,-2,-3,1], K = 5 输出：7 解释： 有 7 个子数组满足其元素之和可被 K = 5 整除： [4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3] 提示： 1 -10000 2 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/subarray-sums-divisible-by-k 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解1 前缀数组和，哈希表。 关键在于表示出序列状态。因为求和能被K整除的连续非空子数组个数，所以用和模K的值作为键构建哈希表。 从左到右遍历数组，当遇到模相同时，加上哈希表对应的个数，再更新哈希表。 import collections class Solution: def subarraysDivByK(self, A: List[int], K: int) -> int: meno = collections.defaultdict(int) meno[0] = 1 # 从数组头开始的子数组 res = 0 presum = 0 for i in A: presum += i tmp = presum%K res += meno[tmp] meno[tmp] += 1 return res 时间复杂度$O(n)$，空间复杂度$O(\\min(n,K))$。 Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-05-27 15:48:47 "},"leetcode/2020_05月/5.28字符串解码.html":{"url":"leetcode/2020_05月/5.28字符串解码.html","title":"5.28 T394.字符串解码","keywords":"","body":"5.28 T394.字符串解码 题目 给定一个经过编码的字符串，返回它解码后的字符串。 编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。 你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。 此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。 示例: s = \"3[a]2[bc]\", 返回 \"aaabcbc\". s = \"3[a2[c]]\", 返回 \"accaccacc\". s = \"2[abc]3[cd]ef\", 返回 \"abcabccdcdcdef\". 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/decode-string 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解1 用栈 class Solution: def decodeString(self, s: str) -> str: stack, num, res = [], 0, '' for c in s: if c.isdigit(): num = num * 10 + int(c) elif c.isalpha(): res += c elif c == '[': stack.append((num, res)) num, res = 0, '' else: in_num, pre_res = stack.pop() res = pre_res + in_num * res return res 时间复杂度$O(n)$，空间复杂度$O(n)$。 Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-05-28 10:46:45 "},"leetcode/2020_05月/5.29打家劫舍.html":{"url":"leetcode/2020_05月/5.29打家劫舍.html","title":"5.29 T198.打家劫舍","keywords":"","body":"5.29 T198.打家劫舍 题目 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。 示例 1: 输入: [1,2,3,1] 输出: 4 解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。 偷窃到的最高金额 = 1 + 3 = 4 。 示例 2: 输入: [2,7,9,3,1] 输出: 12 解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。 偷窃到的最高金额 = 2 + 9 + 1 = 12 。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/house-robber 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解1 动态规划，dp[i]表示前i+1间屋子最多偷窃金额。则状态转移为： dp[i]=max(dp[i−1],dp[i−2]+nums[i]) dp[i] = max(dp[i-1], dp[i-2]+nums[i]) dp[i]=max(dp[i−1],dp[i−2]+nums[i]) 当前房子偷：对应最大金额为dp[i-2]+nums[i] 当前房子不偷：则为dp[i-1] class Solution: def rob(self, nums: List[int]) -> int: if len(nums)==0: return 0 n = len(nums) dp = [0]*n for i in range(n): if i==0: dp[i] = nums[i] elif i==1: dp[i] = max(nums[0], nums[1]) else: dp[i] = max(dp[i-1], dp[i-2]+nums[i]) return dp[-1] 时间复杂度$O(n)$，空间复杂度$O(n)$。 观察状态转移每次只用了dp[i-1], dp[i-2]，所以用两个变量存储，不断更新，减小空间存储。 class Solution: def rob(self, nums: List[int]) -> int: n = len(nums) if n==0: return 0 if n==1: return nums[0] a, b = nums[0], max(nums[0], nums[1]) for i in range(2, n): a, b = b, max(a+nums[i], b) return b # cur, pre = 0, 0 # for num in nums: # cur, pre = max(pre + num, cur), cur # return cur 时间复杂度$O(n)$，空间复杂度$O(1)$。 Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-05-29 10:39:39 "},"leetcode/2020_05月/5.30柱状图中最大的矩形.html":{"url":"leetcode/2020_05月/5.30柱状图中最大的矩形.html","title":"5.30 T84.柱状图中最大的矩形","keywords":"","body":"5.30 T84.柱状图中最大的矩形 题目 给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。 求在该柱状图中，能够勾勒出来的矩形的最大面积。 以上是柱状图的示例，其中每个柱子的宽度为 1，给定的高度为 [2,1,5,6,2,3]。 图中阴影部分为所能勾勒出的最大矩形面积，其面积为 10 个单位。 示例: 输入: [2,1,5,6,2,3] 输出: 10 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/largest-rectangle-in-histogram/ 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解1 单调栈 维护一个递增的单调栈，记录索引和高度。 class Solution: def largestRectangleArea(self, heights: List[int]) -> int: stack = [] n = len(heights) res = 0 for i in range(n): while stack and stack[-1][1]>=heights[i]: ind, hig = stack.pop() tmp = stack[-1][0] if stack else -1 res = max(res, (i-tmp-1)*hig) stack.append((i, heights[i])) for i in range(len(stack)): if i==0: left = -1 else: left = stack[i-1][0] res = max(res, (stack[-1][0]-left)*stack[i][1]) return res 时间复杂度$O(n)$，空间复杂度$O(n)$。 同上： class Solution: def largestRectangleArea(self, heights: List[int]) -> int: n = len(heights) left, right = [0] * n, [0] * n # 从左到右遍历，找到左边界(左边第一个比它小的索引) mono_stack = list() for i in range(n): while mono_stack and heights[mono_stack[-1]] >= heights[i]: mono_stack.pop() left[i] = mono_stack[-1] if mono_stack else -1 mono_stack.append(i) # 从右到左遍历，找到右边界(右边第一个比它小的索引) mono_stack = list() for i in range(n - 1, -1, -1): while mono_stack and heights[mono_stack[-1]] >= heights[i]: mono_stack.pop() right[i] = mono_stack[-1] if mono_stack else n mono_stack.append(i) ans = max((right[i] - left[i] - 1) * heights[i] for i in range(n)) if n > 0 else 0 return ans # 作者：LeetCode-Solution # 链接：https://leetcode-cn.com/problems/largest-rectangle-in-histogram/solution/zhu-zhuang-tu-zhong-zui-da-de-ju-xing-by-leetcode-/ # 来源：力扣（LeetCode） # 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 优化： class Solution: def largestRectangleArea(self, heights: List[int]) -> int: n = len(heights) left, right = [0] * n, [n] * n mono_stack = list() for i in range(n): while mono_stack and heights[mono_stack[-1]] >= heights[i]: right[mono_stack[-1]] = i mono_stack.pop() left[i] = mono_stack[-1] if mono_stack else -1 mono_stack.append(i) ans = max((right[i] - left[i] - 1) * heights[i] for i in range(n)) if n > 0 else 0 return ans # 作者：LeetCode-Solution # 链接：https://leetcode-cn.com/problems/largest-rectangle-in-histogram/solution/zhu-zhuang-tu-zhong-zui-da-de-ju-xing-by-leetcode-/ # 来源：力扣（LeetCode） # 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-05-30 10:29:48 "},"leetcode/2020_05月/5.31对称二叉树.html":{"url":"leetcode/2020_05月/5.31对称二叉树.html","title":"5.31 T101.对称二叉树","keywords":"","body":"5.31 T101.对称二叉树 题目 给定一个二叉树，检查它是否是镜像对称的。 例如，二叉树 [1,2,2,3,4,4,3] 是对称的。 1 / \\ 2 2 / \\ / \\ 3 4 4 3 但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的: 1 / \\ 2 2 \\ \\ 3 3 进阶： 你可以运用递归和迭代两种方法解决这个问题吗？ 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/symmetric-tree 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解1 递归 判断两个根节点lr, rr是否相同，再分别判断lr.left, rr.right及lr.right, rr.left。 # Definition for a binary tree node. # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution: def isSymmetric(self, root: TreeNode) -> bool: def dfs(lr, rr): if not lr and not rr: return True if (not lr and rr) or (lr and not rr): return False # if not lr or not rr: reutrn False # 同上 if lr.val!=rr.val: return False return dfs(lr.left, rr.right) and dfs(lr.right, rr.left) if not root: return True return dfs(root.left, root.right) 题解2 迭代 使用队列，模拟递归过程。 C++代码如下： class Solution { public: bool check(TreeNode *u, TreeNode *v) { queue q; q.push(u); q.push(v); while (!q.empty()) { u = q.front(); q.pop(); v = q.front(); q.pop(); if (!u && !v) continue; if ((!u || !v) || (u->val != v->val)) return false; q.push(u->left); q.push(v->right); q.push(u->right); q.push(v->left); } return true; } bool isSymmetric(TreeNode* root) { return check(root, root); } }; // 作者：LeetCode-Solution // 链接：https://leetcode-cn.com/problems/symmetric-tree/solution/dui-cheng-er-cha-shu-by-leetcode-solution/ // 来源：力扣（LeetCode） // 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-05-31 10:04:29 "},"leetcode/2020_06月/":{"url":"leetcode/2020_06月/","title":"6月每题","keywords":"","body":"6月每题 Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-06-02 09:51:25 "},"leetcode/2020_06月/面试题64.求1+2+…+n.html":{"url":"leetcode/2020_06月/面试题64.求1+2+…+n.html","title":"6.02 面试题64.求1+2+…+n","keywords":"","body":"6.02 面试题64.求1+2+…+n 题目 求 1+2+...+n ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。 示例 1： 输入: n = 3 输出: 6 示例 2： 输入: n = 9 输出: 45 限制： 1 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/qiu-12n-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解1 题目要求不能使用乘除、循环、条件判断。 能用到的就只有位运算。 以下代码不满足题目要求，我使用了平方运算（实质还是乘法） class Solution: def sumNums(self, n: int) -> int: a = n&1 half = n>>1 odd_cnt = half + a even_cnt = half return odd_cnt**2 + even_cnt**2 + even_cnt 题解2 递归 难点：递归终止条件不能使用if，可利用and的短路性质实现递归停止条件。 class Solution: def sumNums(self, n: int) -> int: def dfs(n): n = n and n+dfs(n-1) return n return dfs(n) 题解3 位运算 题目要求1 ，因为$2^14=16384$，n的二进制位最多14位。目标计算$\\frac{n*(n+1)}{2}$ 除以2可以使用>>1，关键是$n*(n+1)$。 考虑$n * 2^k \\ = \\ n class Solution: def sumNums(self, n: int) -> int: def dfs(A, B): ans = (B&1) and A ans += (B and dfs(A>1)) # 利用and，结束递归 return ans return dfs(n, n+1)>>1 Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-06-02 10:35:59 "},"leetcode/2020_06月/6.03新21点.html":{"url":"leetcode/2020_06月/6.03新21点.html","title":"6.03 T837.新21点","keywords":"","body":"6.03 T837.新21点 题目 爱丽丝参与一个大致基于纸牌游戏 “21点” 规则的游戏，描述如下： 爱丽丝以 0 分开始，并在她的得分少于 K 分时抽取数字。 抽取时，她从 [1, W] 的范围中随机获得一个整数作为分数进行累计，其中 W 是整数。 每次抽取都是独立的，其结果具有相同的概率。 当爱丽丝获得不少于 K 分时，她就停止抽取数字。 爱丽丝的分数不超过 N 的概率是多少？ 示例 1： 输入：N = 10, K = 1, W = 10 输出：1.00000 说明：爱丽丝得到一张卡，然后停止。 示例 2： 输入：N = 6, K = 1, W = 10 输出：0.60000 说明：爱丽丝得到一张卡，然后停止。 在 W = 10 的 6 种可能下，她的得分不超过 N = 6 分。 示例 3： 输入：N = 21, K = 17, W = 10 输出：0.73278 提示： 0 1 如果答案与正确答案的误差不超过 10^-5，则该答案将被视为正确答案通过。 此问题的判断限制时间已经减少。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/new-21-game 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解1 记忆化+递归 第96个样例超时。 9811 8776 1096 python3代码如下： class Solution: def new21Game(self, N: int, K: int, W: int) -> float: meno = {} def dfs(start): if start in meno: return meno[start] if start>=K: if start 时间复杂度应该是$O(KW)$，空间复杂度$O(K+W)$ 题解2 利用后缀数组和简化 class Solution: def new21Game(self, N: int, K: int, W: int) -> float: if K==0: return 1 li = [0]*K ans = [0]*(K+1) for i in range(K-1, -1, -1): if i==K-1: if i+W 时间复杂度应该是$O(K)$，空间复杂度$O(K)$ Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-06-03 11:18:36 "},"leetcode/2020_06月/6.04除自身以外数组的乘积.html":{"url":"leetcode/2020_06月/6.04除自身以外数组的乘积.html","title":"6.04 T238.除自身以外数组的乘积","keywords":"","body":"6.04 T238.除自身以外数组的乘积 题目 给你一个长度为 n 的整数数组 nums，其中 n > 1，返回输出数组 output ，其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。 示例: 输入: [1,2,3,4] 输出: [24,12,8,6] 提示： 题目数据保证数组之中任意元素的全部前缀元素和后缀（甚至是整个数组）的乘积都在 32 位整数范围内。 说明: 请不要使用除法，且在 O(n) 时间复杂度内完成此题。 进阶： 你可以在常数空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组不被视为额外空间。） 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/product-of-array-except-self 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解1 核心思想： 两个数组，left[i]存储nums[:i]的累乘 right[i]存储nums[i+1:]的累乘 则除去nums[i]的其余数累乘就等于left[i] * right[i] 以下代码是实现简化，用返回结果暂存left[i]，然后再从右到左遍历一次，乘以right[i]，得到最终结果。 class Solution: def productExceptSelf(self, nums: List[int]) -> List[int]: n = len(nums) res = [1]*n tmp = 1 for i in range(1, n): tmp *= nums[i-1] res[i] = tmp tmp = 1 for i in range(n-2, -1, -1): tmp *= nums[i+1] res[i] *= tmp return res 时间复杂度$O(n)$，除去返回结果空间复杂度$O(1)$。 Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-06-04 09:58:42 "},"leetcode/2020_06月/6.05顺时针打印矩阵.html":{"url":"leetcode/2020_06月/6.05顺时针打印矩阵.html","title":"6.05 面试题29.顺时针打印矩阵","keywords":"","body":"6.05 面试题29.顺时针打印矩阵 题目 输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。 示例 1： 输入：matrix = [[1,2,3],[4,5,6],[7,8,9]] 输出：[1,2,3,6,9,8,7,4,5] 示例 2： 输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]] 输出：[1,2,3,4,8,12,11,10,9,5,6,7] 限制： 0 0 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解 模拟，用dw, up; le, ri确定遍历范围。 class Solution: def spiralOrder(self, matrix: List[List[int]]) -> List[int]: if len(matrix)==0: return [] m, n = len(matrix), len(matrix[0]) res = [] cnt = m*n steps = [(0, 1), (1, 0), (0, -1), (-1, 0)] x, y, k = 0, 0, 0 up, le = -1, -1 dw, ri = m, n while cnt>0: res.append(matrix[x][y]) cnt -= 1 tmp = k while cnt and not(up 时间复杂度$O(n)$，空间复杂度$O(1)$ 改进：由dw, up; le, ri这些范围，可以直接将最外层matrix[dw][le:ri+1], matrix[ri][dw:up+1], matrix[up][ri:le-1:-1], matrix[le][up:dw-1:-1]的值拿出，然后再剥去最外层dw+=1, up-=1, le+=1, ri-=1。 Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-06-05 09:46:11 "},"leetcode/2020_06月/6.06最长连续序列.html":{"url":"leetcode/2020_06月/6.06最长连续序列.html","title":"6.06 T128.最长连续序列","keywords":"","body":"6.06 T128.最长连续序列 题目 给定一个未排序的整数数组，找出最长连续序列的长度。 要求算法的时间复杂度为 O(n)。 示例: 输入: [100, 4, 200, 1, 3, 2] 输出: 4 解释: 最长连续序列是 [1, 2, 3, 4]。它的长度为 4。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/longest-consecutive-sequence 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解1 个人思路，使用一个哈希表meno[i]存储以数i确定的连续序列长度。实际操纵中只需更新连续序列的左右端点的哈希表，meno[i] = length， 若length>0，表示从i起，向右有length个连续序列。例：meno[2]=3表示数组中已遍历有2,3,4 若length，表示从i起，向左有length个连续数。例：meno[2]=2表示数组已遍历有2,1 class Solution: def longestConsecutive(self, nums: List[int]) -> int: meno = {} res = 0 for i in nums: if i in meno: continue # 再次出现跳过 le, ri = i-1, i+1 meno[i] = 1 res = max(res, 1) # i连接两边 if le in meno and ri in meno: if meno[le]=-1: a, b = abs(meno[le]), abs(meno[ri]) length = a+b+1 res = max(res, length) meno[le-a+1] = length meno[ri+b-1] = -length continue # i连接一边 if le in meno: if meno[le]=-1: length = abs(meno[ri])+1 res = max(res, length) meno[i] = length meno[i+length-1] = -length continue # print(meno) return res 时间复杂度$O(n)$，空间复杂度$O(n)$ 题解2 leetcode官方题解，也使用hash class Solution: def longestConsecutive(self, nums: List[int]) -> int: res = 0 num_set = set(nums) for i in num_set: # 未遍历的左端节点 if i-1 not in num_set: length = 1 num = i while num+1 in num_set: length += 1 num += 1 res = max(res, length) return res 时间复杂度$O(n)$，空间复杂度$O(n)$ 题解3 并查集 遍历数组，对num不断合并num-1，num+1对应的集合。最后返回最长集合长度。 python3编程实现难度在于，如何对所有指向同一个集合的数在$O(1)$时间内合并。 class Solution: # 并查集 运用索引指向 构造类似一颗树的结构 每棵树对应一个集合 # 同属一棵树，表示在一个集合 class UnionFind: def __init__(self): self.parent = {} def find(self, index): if index==self.parent[index]: return index self.parent[index] = self.find(self.parent[index]) return self.parent[index] def union(self, index1, index2): self.parent[self.find(index1)] = self.find(index2) def longestConsecutive(self, nums: List[int]) -> int: UF = self.UnionFind() for i in nums: if i in UF.parent: continue UF.parent[i] = i if i-1 in UF.parent: UF.union(i, i-1) if i+1 in UF.parent: UF.union(i, i+1) # print(UF.parent) cnts = {} res = 0 for i in UF.parent: r = UF.find(i) cnts[r] = cnts[r]+1 if r in cnts else 1 res = max(res, cnts[r]) # print(cnts) return res Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-06-08 12:23:10 "},"leetcode/2020_06月/6.07单词接龙II.html":{"url":"leetcode/2020_06月/6.07单词接龙II.html","title":"6.07 T126.单词接龙II","keywords":"","body":"6.07 T126.单词接龙II 题目 给定两个单词（beginWord 和 endWord）和一个字典 wordList，找出所有从 beginWord 到 endWord 的最短转换序列。转换需遵循如下规则： 每次转换只能改变一个字母。 转换过程中的中间单词必须是字典中的单词。 说明: 如果不存在这样的转换序列，返回一个空列表。 所有单词具有相同的长度。 所有单词只由小写字母组成。 字典中不存在重复的单词。 你可以假设 beginWord 和 endWord 是非空的，且二者不相同。 示例 1: 输入: beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"] 输出: [ [\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"], [\"hit\",\"hot\",\"lot\",\"log\",\"cog\"] ] 示例 2: 输入: beginWord = \"hit\" endWord = \"cog\" wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"] 输出: [] 解释: endWord \"cog\" 不在字典中，所以不存在符合要求的转换序列。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/word-ladder-ii 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解 根据单词列表建立无向图，再从beginWord开始广度优先搜索，返回到达endWord的最近路径单词。 from collections import defaultdict from typing import List from collections import deque import string class Solution: def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]: # 先将 wordList 放到哈希表里，便于判断某个单词是否在 wordList 里 word_set = set(wordList) res = [] if len(word_set) == 0 or endWord not in word_set: return res successors = defaultdict(set) # 第 1 步：使用广度优先遍历得到后继结点列表 successors # key：字符串，value：广度优先遍历过程中 key 的后继结点列表 found = self.__bfs(beginWord, endWord, word_set, successors) if not found: return res # 第 2 步：基于后继结点列表 successors ，使用回溯算法得到所有最短路径列表 path = [beginWord] self.__dfs(beginWord, endWord, successors, path, res) return res def __bfs(self, beginWord, endWord, word_set, successors): queue = deque() queue.append(beginWord) visited = set() visited.add(beginWord) found = False word_len = len(beginWord) next_level_visited = set() while queue: current_size = len(queue) for i in range(current_size): current_word = queue.popleft() word_list = list(current_word) for j in range(word_len): origin_char = word_list[j] for k in string.ascii_lowercase: word_list[j] = k next_word = ''.join(word_list) if next_word in word_set: if next_word not in visited: if next_word == endWord: found = True next_level_visited.add(next_word) queue.append(next_word) successors[current_word].add(next_word) word_list[j] = origin_char if found: break # 取两集合全部的元素（并集，等价于将 next_level_visited 里的所有元素添加到 visited 里） visited |= next_level_visited next_level_visited.clear() return found def __dfs(self, beginWord, endWord, successors, path, res): if beginWord == endWord: res.append(path[:]) return if beginWord not in successors: return successor_words = successors[beginWord] for next_word in successor_words: path.append(next_word) self.__dfs(next_word, endWord, successors, path, res) path.pop() if __name__ == '__main__': beginWord = \"hit\" endWord = \"cog\" wordList = [\"hot\", \"dot\", \"dog\", \"lot\", \"log\", \"cog\"] solution = Solution() res = solution.findLadders(beginWord, endWord, wordList) print(res) # 作者：liweiwei1419 # 链接：https://leetcode-cn.com/problems/word-ladder-ii/solution/yan-du-you-xian-bian-li-shuang-xiang-yan-du-you--2/ # 来源：力扣（LeetCode） # 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 题解2 超时，通过样例32/39 import collections class Solution: def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]: if endWord not in wordList or len(beginWord)!=len(endWord): return [] word_id = {} wordList.append(beginWord) n = len(wordList) m = len(beginWord) for i in range(n): word_id[wordList[i]] = i edges = dict.fromkeys(list(range(n))) for i in range(n): edges[i] = set() for i in range(n): for j in range(i, n): w1, w2 = wordList[i], wordList[j] cnt = 0 for a, b in zip(w1, w2): cnt += (a==b) if cnt==m-1: edges[i].add(j) edges[j].add(i) INF = int(1e9) res = [] queue = collections.deque() queue.append([n-1]) cost = [INF]*n cost[n-1] = 0 while queue: li = queue.popleft() ind = li[-1] if ind==word_id[endWord]: queue.appendleft(li) break for i in edges[ind]: if cost[ind]+1 参考学习 # 双向BFS， 弄懂了 class Solution: def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]: tree, words, n = collections.defaultdict(set), set(wordList), len(beginWord) if endWord not in wordList: return [] found, bq, eq, nq, rev = False, {beginWord}, {endWord}, set(), False while bq and not found: words -= set(bq) for x in bq: for i in range(n): first, second = x[:i], x[i+1:] for c in 'qwertyuiopasdfghjklzxcvbnm': y = first + c + second if y in words: if y in eq: found = True else: nq.add(y) tree[y].add(x) if rev else tree[x].add(y) bq, nq = nq, set() if len(bq) > len(eq): bq, eq, rev = eq, bq, not rev def bt(x): return [[x]] if x == endWord else [[x] + rest for y in tree[x] for rest in bt(y)] return bt(beginWord) class Solution: def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]: L = len(beginWord) wordList.append(beginWord) ### 构建具有邻接关系的桶 buckets = defaultdict(list) for word in wordList: for i in range(L): match = word[:i] + '_' + word[i+1:] buckets[match].append(word) ##### BFS遍历 preWords = defaultdict(list) # 前溯词列表 toSeen = deque([(beginWord, 1)]) # 待遍历词及深度列表 beFound = {beginWord:1} # 已探测词词列表 while toSeen: # 还有待探测单词 curWord, level = toSeen.popleft() # 弹出最左边 for i in range(L): # 循环beginWord的长度 match = curWord[:i] + '_' + curWord[i+1:] # 把弹出单词的i改成_ for word in buckets[match]: # 循环与match具有邻接关系的单词列表 if word not in beFound: # 如果word不在已探测词词列表 beFound[word] = level+1 # 以当前循环的单词为键，当前深度为值 toSeen.append((word, level+1)) if beFound[word] == level+1: # 当前深度等于该词首次遍历深度，则仍应加入前溯词列表 preWords[word].append(curWord) # 给前溯词列表增加：当前单词，当前深度 if endWord in beFound and level+1 > beFound[endWord]: # 已搜索到目标词，且完成当前层遍历 break #### 列表推导式输出结果 if endWord in beFound: # 如果结尾在 res = [[endWord]] while res[0][0] != beginWord: res = [[word] + r for r in res for word in preWords[r[0]]] return res else: return [] Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-06-10 17:54:08 "},"leetcode/2020_06月/6.08等式方程的可满足性.html":{"url":"leetcode/2020_06月/6.08等式方程的可满足性.html","title":"6.08 T990.等式方程的可满足性","keywords":"","body":"6.08 T990.等式方程的可满足性 题目 给定一个由表示变量之间关系的字符串方程组成的数组，每个字符串方程 equations[i] 的长度为 4，并采用两种不同的形式之一：\"a==b\" 或 \"a!=b\"。在这里，a 和 b 是小写字母（不一定不同），表示单字母变量名。 只有当可以将整数分配给变量名，以便满足所有给定的方程时才返回 true，否则返回 false。 示例 1： 输入：[\"a==b\",\"b!=a\"] 输出：false 解释：如果我们指定，a = 1 且 b = 1，那么可以满足第一个方程，但无法满足第二个方程。没有办法分配变量同时满足这两个方程。 示例 2： 输出：[\"b==a\",\"a==b\"] 输入：true 解释：我们可以指定 a = 1 且 b = 1 以满足满足这两个方程。 示例 3： 输入：[\"a==b\",\"b==c\",\"a==c\"] 输出：true 示例 4： 输入：[\"a==b\",\"b!=c\",\"c==a\"] 输出：false 示例 5： 输入：[\"c==c\",\"b==d\",\"x!=z\"] 输出：true 提示： 1 equations[i].length == 4 equations[i][0] 和 equations[i][3] 是小写字母 equations[i][1] 要么是 '='，要么是 '!' equations[i][2] 是 '=' 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/satisfiability-of-equality-equations 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解 并查集 当是==时，表示两边相等，将对应集合合并。同一集合中的所有元素相等。 最后访问a!=b，若a, b在同一个集合中，则返回False class Solution: # 构建并查集 class UnionFind: def __init__(self): self.parent = list(range(26)) def find(self, index): if index == self.parent[index]: return index self.parent[index] = self.find(self.parent[index]) return self.parent[index] def union(self, index1, index2): self.parent[self.find(index1)] = self.find(index2) def equationsPossible(self, equations: List[str]) -> bool: UF = self.UnionFind() stack = [] for s in equations: if s[1]=='=': a, b = ord(s[0])-97, ord(s[-1])-97 UF.union(a, b) else: stack.append(s) while stack: s = stack.pop() r1 = UF.find(ord(s[0])-97) r2 = UF.find(ord(s[-1])-97) if r1==r2: return False return True Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-06-08 12:36:31 "},"leetcode/2020_06月/6.09把数字翻译成字符串.html":{"url":"leetcode/2020_06月/6.09把数字翻译成字符串.html","title":"6.09 面试题46.把数字翻译成字符串","keywords":"","body":"6.09 面试题46.把数字翻译成字符串 题目 给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。 示例 1: 输入: 12258 输出: 5 解释: 12258有5种不同的翻译，分别是\"bccfi\", \"bwfi\", \"bczi\", \"mcfi\"和\"mzi\" 提示： 0 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解1 动态规划 dp[i]表示到第i位时，有多少种翻译方法。 如果可以和前一位组成合法翻译，即9 ，则dp[i] = dp[i-2] + dp[i-1] 如果不能，则dp[i] = dp[i-1] class Solution: def translateNum(self, num: int) -> int: s = str(num) n = len(s) dp = [1]*n for i in range(n): if i==0: continue if s[i-1]!='0' and int(s[i-1:i+1]) 时间复杂度$O(\\log n)$，空间复杂度$O(\\log n)$ 因为将整数n转为字符串共$\\log_{10}n$ 位。 dp[i]可优化，p = dp[i-2]; q = dp[i-1]; r = dp[i] 题解2 dfs class Solution: def translateNum(self, num: int) -> int: def dfs(num): if num Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-06-09 11:13:12 "},"leetcode/2020_06月/6.10回文数.html":{"url":"leetcode/2020_06月/6.10回文数.html","title":"6.10 T9.回文数","keywords":"","body":"6.10 T9.回文数 题目 判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。 示例 1: 输入: 121 输出: true 示例 2: 输入: -121 输出: false 解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。 示例 3: 输入: 10 输出: false 解释: 从右向左读, 为 01 。因此它不是一个回文数。 进阶: 你能不将整数转为字符串来解决这个问题吗？ 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/palindrome-number 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解1 翻转一半的数 例如： x = 12421，从尾部依次翻转至x = 12, a = 124 x = 321123，从尾部依次翻转为x = 321, a = 321 class Solution: def isPalindrome(self, x: int) -> bool: if x 时间复杂度$O(\\log n)$，空间复杂度$O(1)$ Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-06-10 12:46:09 "},"leetcode/2020_06月/6.11每日温度.html":{"url":"leetcode/2020_06月/6.11每日温度.html","title":"6.11 T739.每日温度","keywords":"","body":"6.11 T739.每日温度 题目 根据每日 气温 列表，请重新生成一个列表，对应位置的输出是需要再等待多久温度才会升高超过该日的天数。如果之后都不会升高，请在该位置用 0 来代替。 例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。 提示 气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/daily-temperatures 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解 单调栈 构建一个单调减的栈。 遇到大于栈顶的值，就退栈，并记录天数(索引)差 class Solution: def dailyTemperatures(self, T: List[int]) -> List[int]: stack = [] res = [0] * len(T) for i in range(len(T)): while stack and T[i]>T[stack[-1]]: a = stack.pop() res[a] = i - a stack.append(i) return res 时间复杂度$O(n)$，空间复杂度$O(n)$ Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-06-11 11:25:45 "},"leetcode/2020_06月/6.12三数之和.html":{"url":"leetcode/2020_06月/6.12三数之和.html","title":"6.12 T15.三数之和","keywords":"","body":"6.12 T15.三数之和 题目 给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。 注意： 答案中不可以包含重复的三元组。 示例： 给定数组 nums = [-1, 0, 1, 2, -1, -4]， 满足要求的三元组集合为： [ [-1, 0, 1], [-1, -1, 2] ] 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/3sum 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解1 遍历三数中最左数，简化为两数之和。 python3代码如下： class Solution: def threeSum(self, nums: List[int]) -> List[List[int]]: n = len(nums) if n0 and nums[i]==nums[i-1]: continue j, k = i+1, n-1 while j0: k -= 1 else: res.append([nums[i], nums[j], nums[k]]) a, b = nums[j], nums[k] while j-1 and b==nums[k]: k -= 1 return res C代码如下： /** * Return an array of arrays of size *returnSize. * Note: The returned array must be malloced, assume caller calls free(). */ void sort(int *nums,int low,int high){ int i,j,temp,turn=0; for(i=low,j=high;inums[j]){ temp=nums[i]; nums[i]=nums[j]; nums[j]=temp; if(turn==0)turn=1; else turn=0; } if(turn==1)i++; else j--; } if(low0&&nums[i]==nums[i-1]) continue; j=i+1,k=numsSize-1; while(j0){ k--; }else if(sum 时间复杂度$O(n^2)$ Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-06-12 14:56:03 "},"leetcode/2020_06月/6.13爬楼梯.html":{"url":"leetcode/2020_06月/6.13爬楼梯.html","title":"6.13 T70.爬楼梯","keywords":"","body":"6.13 T70.爬楼梯 题目 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 注意：给定 n 是一个正整数。 示例 1： 输入： 2 输出： 2 解释： 有两种方法可以爬到楼顶。 1. 1 阶 + 1 阶 2. 2 阶 示例 2： 输入： 3 输出： 3 解释： 有三种方法可以爬到楼顶。 1. 1 阶 + 1 阶 + 1 阶 2. 1 阶 + 2 阶 3. 2 阶 + 1 阶 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/climbing-stairs 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解1 动态规划 --> 改进 数组dp[i]表示爬到第i层的方法数，则 初始状态：dp[0]=1, dp[1]=1 状态转移：dp[i] = dp[i-1] + dp[i-2] （从第i-1层走一个台阶或从第i-2层走两个台阶） 观察和斐波拉契数列一样，那么只用两个变量存值即可 class Solution: def climbStairs(self, n: int) -> int: a, b = 1, 1 for i in range(1, n): a, b = b, a+b return b 时间复杂度$O(n)$，空间复杂度$O(1)$ 题解2 直接使用斐波拉契数列递推公式 f(n)=15[(1+52)n−(1−52)n]f(n) = \\frac{1}{\\sqrt{5}} [ (\\frac{1+\\sqrt{5}}{2})^n - (\\frac{1-\\sqrt{5}}{2})^n ]f(n)=​√​5​​​​​1​​[(​2​​1+√​5​​​​​)​n​​−(​2​​1−√​5​​​​​)​n​​] Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-06-13 16:48:57 "},"leetcode/2020_06月/6.14转变数组后最接近目标值的数组和.html":{"url":"leetcode/2020_06月/6.14转变数组后最接近目标值的数组和.html","title":"6.14 T1300.转变数组后最接近目标值的数组和","keywords":"","body":"6.14 T1300.转变数组后最接近目标值的数组和 题目 给你一个整数数组 arr 和一个目标值 target ，请你返回一个整数 value ，使得将数组中所有大于 value 的值变成 value 后，数组的和最接近 target （最接近表示两者之差的绝对值最小）。 如果有多种使得和最接近 target 的方案，请你返回这些整数中的最小值。 请注意，答案不一定是 arr 中的数字。 示例 1： 输入：arr = [4,9,3], target = 10 输出：3 解释：当选择 value 为 3 时，数组会变成 [3, 3, 3]，和为 9 ，这是最接近 target 的方案。 示例 2： 输入：arr = [2,3,5], target = 10 输出：5 示例 3： 输入：arr = [60864,25176,27249,21296,20204], target = 56803 输出：11361 提示： 1 1 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/sum-of-mutated-array-closest-to-target 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解 先将数组进行排序 依次遍历，找到替换后大于target则退出循环；记录已遍历前序和su，剩余个数cnt res = (target-su)//cnt，比较替换res或res+1谁更接近target class Solution: def findBestValue(self, arr: List[int], target: int) -> int: arr.sort() INF = int(1e9) ind, diff = -1, INF n = len(arr) # print(arr) su = 0 for i in range(n): tmp = su + (n-i)*arr[i] if tmptarget: break su += arr[i] if diff==0 or ind==n-1: return arr[ind] cnt = n-ind-1 res = (target-su)//cnt if abs(su+res*cnt-target) 除去排序，则时间复杂度$O(n)$，空间复杂度$O(1)$ Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-06-14 16:11:56 "},"leetcode/2020_06月/6.15最长公共前缀.html":{"url":"leetcode/2020_06月/6.15最长公共前缀.html","title":"6.15 T14.最长公共前缀","keywords":"","body":"6.15 T14.最长公共前缀 题目 编写一个函数来查找字符串数组中的最长公共前缀。 如果不存在公共前缀，返回空字符串 \"\"。 示例 1: 输入: [\"flower\",\"flow\",\"flight\"] 输出: \"fl\" 示例 2: 输入: [\"dog\",\"racecar\",\"car\"] 输出: \"\" 解释: 输入不存在公共前缀。 说明: 所有输入只包含小写字母 a-z 。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/longest-common-prefix 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解1 暴力，依次取前缀子字符串，判断是否是公共子字符串 class Solution: def longestCommonPrefix(self, strs: List[str]) -> str: if not strs: return '' min_len = min(len(s) for s in strs) res = '' for i in range(1, min_len+1): temp = strs[0][:i] for s in strs: if s[:i] != temp: break else: res = temp return res 题解2 递归，二分 递归查看每两个字符串的最长公共子串 查看两个字符串的最长公共子串使用二分 class Solution: def longestCommonPrefix(self, strs: List[str]) -> str: def fun(s1, s2): m, n = len(s1), len(s2) if m>n: s1, s2, m ,n = s2, s1, n, m left, right = 0, m while left>1 if s1[:mid+1]==s2[:mid+1]: left = mid + 1 else: right = mid return s1[:left] res = None for s in strs: if res==None: res = s elif res=='': return '' else: res = fun(res, s) return res if res!=None else '' 题解3 字典树 from collections import defaultdict from functools import reduce class Solution: def longestCommonPrefix(self, strs: List[str]) -> str: Trie = lambda: defaultdict(Trie) trie = Trie() for s in strs: if s=='': return '' reduce(dict.__getitem__, s, trie)['END'] = True # 结束尾部，防止出现[\"aa\", \"a\"]返回\"aa\"的情况 res = '' tmp = trie # print(tmp) while len(tmp.keys())==1: c = list(tmp.keys())[0] if c=='END': break res += c tmp = tmp[c] return res Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-06-15 12:29:58 "},"leetcode/2020_06月/6.16二叉树的序列化与反序列化.html":{"url":"leetcode/2020_06月/6.16二叉树的序列化与反序列化.html","title":"6.16 T297.二叉树的序列化与反序列化","keywords":"","body":"6.16 T297.二叉树的序列化与反序列化 题目 序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。 请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。 示例: 你可以将以下二叉树： 1 / \\ 2 3 / \\ 4 5 序列化为 \"[1,2,3,null,null,4,5]\" 提示: 这与 LeetCode 目前使用的方式一致，详情请参阅 LeetCode 序列化二叉树的格式。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。 说明: 不要使用类的成员 / 全局 / 静态变量来存储状态，你的序列化和反序列化算法应该是无状态的。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 [5,2,3,null,null,2,4,3,1] 5 / \\ 2 3 / \\ 2 4 / \\ 3 1 题解 题目意思就是： 输入一个字符串，将其转换为对应的二叉树结构 将转换完的二叉树结构，再按照转换规则反向变为字符串 这里使用的转换规则是：BFS广度优先遍历 # Definition for a binary tree node. # class TreeNode(object): # def __init__(self, x): # self.val = x # self.left = None # self.right = None import collections class Codec: def serialize(self, root): \"\"\"Encodes a tree to a single string. :type root: TreeNode :rtype: str \"\"\" if not root: return '[]' queue = collections.deque() queue.append(root) # cnt记录队列里的有效节点个数，当其为0时则可退出，避免后续的null res, cnt = '', 1 while queue and cnt>0: a = queue.popleft() if len(res)==0: res += '[' if not a: res += 'null,' else: cnt -= 1 res += str(a.val)+',' queue.append(a.left) queue.append(a.right) cnt += (a.left!=None) + (a.right!=None) res = res[:-1]+']' return res def deserialize(self, data): \"\"\"Decodes your encoded data to tree. :type data: str :rtype: TreeNode \"\"\" li = data[1:-1].split(',') treeli = collections.deque() root = None isleft = True for i in range(len(li)): a = li[i] if root==None: if len(a)==0 or a=='null': return None root = TreeNode(int(a)) treeli.append(root) else: parent = treeli[0] node = TreeNode(int(a)) if a!='null' else None if isleft: parent.left = node else: parent.right = node treeli.popleft() if node: treeli.append(node) isleft = not isleft return root # Your Codec object will be instantiated and called as such: # codec = Codec() # codec.deserialize(codec.serialize(root)) Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-06-16 20:48:26 "},"leetcode/2020_06月/6.17最佳观光组合.html":{"url":"leetcode/2020_06月/6.17最佳观光组合.html","title":"6.17 T1014.最佳观光组合","keywords":"","body":"6.17 T1014.最佳观光组合 题目 给定正整数数组 A，A[i] 表示第 i 个观光景点的评分，并且两个景点 i 和 j 之间的距离为 j - i。 一对景点（i 返回一对观光景点能取得的最高分。 示例： 输入：[8,1,5,2,6] 输出：11 解释：i = 0, j = 2, A[i] + A[j] + i - j = 8 + 5 + 0 - 2 = 11 提示： 2 1 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/best-sightseeing-pair 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解1 最明显的方法就是暴力，枚举所有的可能性，时间复杂度$O(n^2)$，观察2 可知$O(n^2)$会超时。 针对暴力法的改进，首先暴力法步骤： 枚举i，n = len(A)，for i in range(n) 枚举j，for j in range(i+1, n)，计算最大值A[i]+A[j]-(j-i) 以示例为例[8,1,5,2,6] 当i=0时，目标是找到[1-1, 5-2, 2-3, 6-4]中的最大值 当i=1时，目标是找到 [5-1, 2-2, 6-3]中的最大值 ... 观察发现后缀的数组最大值索引是相同的。 用一个数组f[i]记录[A[i], A[i+1]-1, A[i+2]-2, ..., A[n-1]-(n-1-i)]最大值对应的索引 class Solution: def maxScoreSightseeingPair(self, A: List[int]) -> int: n = len(A) f = [0]*n # f[i]表示[A[i], A[i+1]-1, A[i+2]-2, ..., A[n-1]-(n-1-i)]最大值对应的索引 for i in range(n-1, -1, -1): if i==n-1: f[i] = i else: a = f[i+1] if A[i]>A[a]-(a-i): f[i] = i else: f[i] = a # print(f) res = 0 for i in range(n-1): a = f[i+1] res = max(res, A[i]+A[a]+i-a) return res 时间复杂度$O(n)$ 题解2 目标A[i]+A[j]-j+i = A[i]+i + A[j]-j 我们枚举j，依次更新最大的A[i]+i class Solution: def maxScoreSightseeingPair(self, A: List[int]) -> int: n = len(A) i = 0 res = 0 for j in range(1, n): if A[j-1]+(j-1)>A[i]+i: i = j-1 res = max(res, A[j]-j+A[i]+i) return res 时间复杂度$O(n)$ Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-06-17 09:05:53 "},"leetcode/2020_06月/6.18从先序遍历还原二叉树.html":{"url":"leetcode/2020_06月/6.18从先序遍历还原二叉树.html","title":"6.18 T1028.从先序遍历还原二叉树","keywords":"","body":"6.18 T1028.从先序遍历还原二叉树 题目 我们从二叉树的根节点 root 开始进行深度优先搜索。 在遍历中的每个节点处，我们输出 D 条短划线（其中 D 是该节点的深度），然后输出该节点的值。（如果节点的深度为 D，则其直接子节点的深度为 D + 1。根节点的深度为 0）。 如果节点只有一个子节点，那么保证该子节点为左子节点。 给出遍历输出 S，还原树并返回其根节点 root。 示例 1： 输入：\"1-2--3--4-5--6--7\" 输出：[1,2,5,3,4,6,7] 示例 2： 输入：\"1-2--3---4-5--6---7\" 输出：[1,2,5,3,null,6,null,4,null,7] 示例 3： 输入：\"1-401--349---90--88\" 输出：[1,401,null,349,88,90] 提示： 原始树中的节点数介于 1 和 1000 之间。 每个节点的值介于 1 和 10 ^ 9 之间。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/recover-a-tree-from-preorder-traversal 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解 观察发现，节点只有一个子节点，那么保证该子节点为左子节点。 当左孩子已有时，再出现同深度的就是右孩子节点。 class Solution: def recoverFromPreorder(self, S: str) -> TreeNode: path, pos = list(), 0 while pos 我的思路和官方一样，但是代码可读性差 class Solution: def recoverFromPreorder(self, S: str) -> TreeNode: path = [] cnt_, i, num = 0, 0, 0 n = len(S) while i0: node = TreeNode(num) if not path and cnt_==0: path.append([node, True]) else: if path[cnt_-1][1]: path[cnt_-1][0].left = node path[cnt_-1][1] = False else: path[cnt_-1][0].right = node if len(path)0: node = TreeNode(num) if cnt_==0: return node if path[cnt_-1][1]: path[cnt_-1][0].left = node else: path[cnt_-1][0].right = node # print(path) if not path: return None node = path[0][0] return node 时间复杂度$O(n)$，字符串长度； 空间复杂度$O(h)$，树的深度。 Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-06-18 11:47:19 "},"leetcode/2020_06月/6.19验证回文串.html":{"url":"leetcode/2020_06月/6.19验证回文串.html","title":"6.19 T125.验证回文串","keywords":"","body":"6.19 T125.验证回文串 题目 给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。 说明：本题中，我们将空字符串定义为有效的回文串。 示例 1: 输入: \"A man, a plan, a canal: Panama\" 输出: true 示例 2: 输入: \"race a car\" 输出: false 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/valid-palindrome 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解 直接双指针 class Solution: def isPalindrome(self, s: str) -> bool: s = s.lower() n = len(s) left, right = 0, n-1 while left-1 and not (s[right].isdigit() or s[right].isalpha()): right -= 1 if left>=right: break if left-1 and s[left]==s[right]: left += 1; right -= 1 else: return False return True class Solution: def isPalindrome(self, s: str) -> bool: sgood = \"\".join(ch.lower() for ch in s if ch.isalnum()) n = len(sgood) left, right = 0, n - 1 while left Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-06-19 21:52:58 "},"leetcode/2020_06月/6.20正则表达式匹配.html":{"url":"leetcode/2020_06月/6.20正则表达式匹配.html","title":"6.20 T10.正则表达式匹配","keywords":"","body":"6.20 T10.正则表达式匹配 题目 给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。 '.' 匹配任意单个字符 '*' 匹配零个或多个前面的那一个元素 所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。 说明: s 可能为空，且只包含从 a-z 的小写字母。 p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。 示例 1: 输入: s = \"aa\" p = \"a\" 输出: false 解释: \"a\" 无法匹配 \"aa\" 整个字符串。 示例 2: 输入: s = \"aa\" p = \"a*\" 输出: true 解释: 因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 \"aa\" 可被视为 'a' 重复了一次。 示例 3: 输入: s = \"ab\" p = \".*\" 输出: true 解释: \".*\" 表示可匹配零个或多个（'*'）任意字符（'.'）。 示例 4: 输入: s = \"aab\" p = \"c*a*b\" 输出: true 解释: 因为 '*' 表示零个或多个，这里 'c' 为 0 个, 'a' 被重复一次。因此可以匹配字符串 \"aab\"。 示例 5: 输入: s = \"mississippi\" p = \"mis*is*p*.\" 输出: false 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/regular-expression-matching 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解 题目要求匹配正则里的.和* .可以匹配一个任意字符 *控制正则前一个字符的个数为0或多个 动态规划 1.从前往后 dp[i][j]表示s[:i]和p[:j]是否匹配 dpm+1行n+1列，m=len(s), n=len(p) 因为*可以匹配0个，所以要考虑：当i==0时，s[:i]为空 动态转移： 遇到.判断对应位置是否相等，匹配s中一个。dp[ii][jj] = dp[ii-1][jj-1] 遇到*，两种情况：*匹配0个；*匹配多个，后种情况有一个前提条件字符是否相等匹配pre_match = p[j-1] in {s[i], '.'} dp[ii][jj] = dp[ii][jj-2] or (pre_match and dp[ii-1][jj]) python代码： class Solution: def isMatch(self, s: str, p: str) -> bool: m, n = len(s), len(p) dp = [[False] *(n+1) for _ in range(m+1)] dp[0][0] = True for ii in range(m+1): for jj in range(1, n+1): if ii==0: if p[jj-1]=='*': dp[ii][jj] = dp[ii][jj-2] continue i, j = ii-1, jj-1 if p[j] in {s[i], '.'}: dp[ii][jj] = dp[ii-1][jj-1] elif p[j]=='*': pre_match = p[j-1] in {s[i], '.'} # 1.不匹配 (2.匹配多个 前提s[i]==p[j-1]) dp[ii][jj] = dp[ii][jj-2] or (pre_match and dp[ii-1][jj]) # print(s[:ii], p[:jj], dp[ii][jj]) return dp[-1][-1] 2.从后往前 dp[i][j]表示s[i:]与p[j:]是否匹配 思路类似，分情况*匹配0个或1个 class Solution: def isMatch(self, s: str, p: str) -> bool: dp = [[False] * (len(p)+1) for _ in range(len(s)+1)] dp[-1][-1] = True for i in range(len(s), -1, -1): for j in range(len(p)-1, -1, -1): # 是否可行 first_match = i 时间复杂度$O(nm)$，空间复杂度$O(mn)$ Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-06-20 20:28:33 "},"leetcode/2020_06月/6.21二叉树中的最大路径和.html":{"url":"leetcode/2020_06月/6.21二叉树中的最大路径和.html","title":"6.21 T124.二叉树中的最大路径和","keywords":"","body":"6.21 T124.二叉树中的最大路径和 题目 给定一个非空二叉树，返回其最大路径和。 本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径至少包含一个节点，且不一定经过根节点。 示例 1: 输入: [1,2,3] 1 / \\ 2 3 输出: 6 示例 2: 输入: [-10,9,20,null,null,15,7] -10 / \\ 9 20 / \\ 15 7 输出: 42 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/binary-tree-maximum-path-sum 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解 找到一条从树中任意节点出发，达到任意节点的序列，使得值最大。一定是要上升0~n个节点到达根节点，再下降0~n个节点。 类似 数组的最大子数组和， meno[root]表示以root为根，最大上升序列值。 # Definition for a binary tree node. # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution: def maxPathSum(self, root: TreeNode) -> int: meno = {} INF = 2**31 self.res = -INF def dfs(root): if root in meno: return if root==None: if None not in meno: meno[None] = 0 return dfs(root.left) dfs(root.right) # 左孩子序列+root.val，右孩子序列+root.val，root.val最大值 meno[root] = max(meno[root.left], meno[root.right], 0) + root.val # 以root为根的路径 跟新 最大值 self.res = max(max(0, meno[root.left]) + max(0, meno[root.right]) + root.val, self.res) dfs(root) return self.res class Solution: def maxPathSum(self, root: TreeNode) -> int: self.res = -2**31 def dfs(root): if not root: return 0 left = dfs(root.left) right = dfs(root.right) self.res = max(self.res, max(0, left)+max(0, right)+root.val) return max(left, right, 0)+root.val dfs(root) return self.res 时间复杂度$O(n)$ Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-06-21 14:00:08 "},"leetcode/2020_06月/6.22面试题模式匹配.html":{"url":"leetcode/2020_06月/6.22面试题模式匹配.html","title":"6.22 面试题16.18.模式匹配","keywords":"","body":"6.22 面试题16.18.模式匹配 题目 你有两个字符串，即pattern和value。 pattern字符串由字母\"a\"和\"b\"组成，用于描述字符串中的模式。例如，字符串\"catcatgocatgo\"匹配模式\"aabab\"（其中\"cat\"是\"a\"，\"go\"是\"b\"），该字符串也匹配像\"a\"、\"ab\"和\"b\"这样的模式。但需注意\"a\"和\"b\"不能同时表示相同的字符串。编写一个方法判断value字符串是否匹配pattern字符串。 示例 1： 输入： pattern = \"abba\", value = \"dogcatcatdog\" 输出： true 示例 2： 输入： pattern = \"abba\", value = \"dogcatcatfish\" 输出： false 示例 3： 输入： pattern = \"aaaa\", value = \"dogcatcatdog\" 输出： false 示例 4： 输入： pattern = \"abba\", value = \"dogdogdogdog\" 输出： true 解释： \"a\"=\"dogdog\",b=\"\"，反之也符合规则 提示： 0 0 你可以假设pattern只包含字母\"a\"和\"b\"，value仅包含小写字母。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/pattern-matching-lcci 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解 因为模式串pattern只有'a'和'b'两种字符，所以枚举pattern出现的第一个字母所代表的字符串。 通过value字符串长度及'a'、'b'的个数，计算另一种字母所代表的字符串。再判断该方案是否成功。 模式串pattern为空，返回value是否为空 value为空，返回模式串是否只有一种字母 模式串只有一种字母，可直接计算该字母是否符合 正常情况，value非空，模式串有两种字母，枚举模式串第一个字母所代表的字符串 import collections class Solution: def patternMatching(self, pattern: str, value: str) -> bool: m, n = len(pattern), len(value) meno = collections.Counter(pattern) if m==0: return n==0 # 如果模式串为空，返回value==空 if n==0: return meno['b']==0 or meno['a']==0 # 如果value为空，返回模式串pattern是否只有一种字母 # 记录第一次出现'a','b'在pattern的索引，以便计算第二种字母代表的字符串 indic = {'a':-1, 'b':-1} for i in range(m): if pattern[i]=='a' and indic['a']==-1: indic['a']=i if pattern[i]=='b' and indic['b']==-1: indic['b']=i # 枚举pattern[0]所代表的字符串，默认枚举'a'(pattern[0]=='a')，否则反转 rev = False if n>0 and pattern[0]=='b': rev = True meno['a'], meno['b'] = meno['b'], meno['a'] indic['a'], indic['b'] = indic['b'], indic['a'] # 当前情况下是否成功匹配value，arg形如a, b def isTrue(rev, *arg): if arg[0]==arg[1]: return False res = 0 li = len(arg[0]), len(arg[1]) # 判断对应索引位置的字符串是否相等，可提前返回False 不用模拟字符串相加 for c in pattern: ind = (ord(c)-97+rev)%2 if value[res:res+li[ind]] != arg[ind]: return False res += li[ind] return True # 模式串只有一种字母 if meno['b']==0 or meno['a']==0: if n%m: return False len_a = n//m a = value[:len_a] return isTrue(rev, a, '') # 枚举'a'代表的字符串(默认pattern[0]=='a'，变量rev表示是否反转) a = '' i = 0 while i=0 and (n-meno['a']*len(a)) % meno['b']==0: len_b = (n-meno['a']*len(a)) // meno['b'] tmp = len(a)*indic['b'] b = value[tmp:tmp+len_b] res = isTrue(rev, a, b) # print(f'a = {a}, b = {b}, res = {res}\\n') if res: return True if i==n: break a += value[i] i += 1 return False 正则匹配，调库 # https://leetcode-cn.com/problems/pattern-matching-lcci/solution/mo-shi-pi-pei-by-leetcode-solution/ import re class Solution: def patternMatching(self, pattern: str, value: str) -> bool: # 边界情况处理 if not pattern: return not value if len(pattern) == 1: return True # 构造正则表达式：重点是正则表达式的“后向引用” rega, regb = ('\\\\1', '\\\\2') if pattern[0] == 'a' else ('\\\\2', '\\\\1') p = pattern.replace('a', '(\\\\w*)', 1).replace('b', '(\\\\w*)', 1).replace('a', rega).replace('b', regb) p = '^' + p + '$' m = re.match(p, value) # 匹配到 && (模式长度为1 || 模式长度为2 && 两个模式不相同) return bool(m and (len(m.groups()) == 1 or m.groups()[0] != m.groups()[1])) Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-06-22 17:25:52 "},"leetcode/2020_06月/6.23二进制求和.html":{"url":"leetcode/2020_06月/6.23二进制求和.html","title":"6.23 T67.二进制求和","keywords":"","body":"6.23 T67.二进制求和 题目 给你两个二进制字符串，返回它们的和（用二进制表示）。 输入为 非空 字符串且只包含数字 1 和 0。 示例 1: 输入: a = \"11\", b = \"1\" 输出: \"100\" 示例 2: 输入: a = \"1010\", b = \"1011\" 输出: \"10101\" 提示： 每个字符串仅由字符 '0' 或 '1' 组成。 1 字符串如果不是 \"0\" ，就都不含前导零。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/add-binary 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解 class Solution: def addBinary(self, a: str, b: str) -> str: res = int(a, 2) + int(b, 2) return bin(res)[2:] class Solution: def addBinary(self, a: str, b: str) -> str: m, n = len(a), len(b) res = '' if m-m-1: tmp = int(a[i]) + int(b[i]) + jin jin = 1 if tmp>1 else 0 res = str(tmp%2) + res i -= 1 if jin: res = '1' + res return res Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-06-24 18:26:43 "},"leetcode/2020_06月/6.24最接近的三数之和.html":{"url":"leetcode/2020_06月/6.24最接近的三数之和.html","title":"6.24 T16.最接近的三数之和","keywords":"","body":"6.24 T16.最接近的三数之和 题目 给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。 示例： 输入：nums = [-1,2,1,-4], target = 1 输出：2 解释：与 target 最接近的和是 2 (-1 + 2 + 1 = 2) 。 提示： 3 -10^3 -10^4 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/3sum-closest 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解 对数组排序后，枚举第一个数字，后两个数字用双指针法。 class Solution: def threeSumClosest(self, nums: List[int], target: int) -> int: res = int(1e9+7) n = len(nums) nums.sort() for i in range(n-2): a = nums[i] left, right = i+1, n-1 while lefttarget: right -= 1 elif tmp 时间复杂度$O(n^2)$，空间复杂度$O(nlog{n})$(排序所需) Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-06-24 18:29:43 "},"leetcode/2020_06月/6.25单词拆分.html":{"url":"leetcode/2020_06月/6.25单词拆分.html","title":"6.25 T139.单词拆分","keywords":"","body":"6.25 T139.单词拆分 题目 给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。 说明： 拆分时可以重复使用字典中的单词。 你可以假设字典中没有重复的单词。 示例 1： 输入: s = \"leetcode\", wordDict = [\"leet\", \"code\"] 输出: true 解释: 返回 true 因为 \"leetcode\" 可以被拆分成 \"leet code\"。 示例 2： 输入: s = \"applepenapple\", wordDict = [\"apple\", \"pen\"] 输出: true 解释: 返回 true 因为 \"applepenapple\" 可以被拆分成 \"apple pen apple\"。 注意你可以重复使用字典中的单词。 示例 3： 输入: s = \"catsandog\", wordDict = [\"cats\", \"dog\", \"sand\", \"and\", \"cat\"] 输出: false 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/word-break 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解 动态规划 f[i]表示s[:i]是否可以由wordDict表示 初始状态：f[0]=True，表示s为空时，不选wordDict即可，满足 状态转移：pre = i-len(wordDict[j]); f[i] = f[pre] and wordDict[j]==s[pre:i]，遍历wordDict class Solution: def wordBreak(self, s: str, wordDict: List[str]) -> bool: n, m = len(s), len(wordDict) f = [False]*(n+1) f[0] = True for i in range(1, n+1): for j in range(m): if i 时间复杂度$O(nm)$，空间复杂度$O(n)$。 Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-06-25 21:36:46 "},"leetcode/2020_06月/6.26面试题02.01.移除重复节点.html":{"url":"leetcode/2020_06月/6.26面试题02.01.移除重复节点.html","title":"6.26 面试题02.01.移除重复节点","keywords":"","body":"6.26 面试题02.01.移除重复节点 题目 编写代码，移除未排序链表中的重复节点。保留最开始出现的节点。 示例1: 输入：[1, 2, 3, 3, 2, 1] 输出：[1, 2, 3] 示例2: 输入：[1, 1, 1, 1, 2] 输出：[1, 2] 提示： 链表长度在[0, 20000]范围内。 链表元素在[0, 20000]范围内。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/remove-duplicate-node-lcci 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解 用一个集合存储已经出现过的值 # Definition for singly-linked list. # class ListNode: # def __init__(self, x): # self.val = x # self.next = None class Solution: def removeDuplicateNodes(self, head: ListNode) -> ListNode: visited = set() res = ListNode(0) p = res i = head while i: if i.val not in visited: p.next = i p = p.next visited.add(i.val) i = i.next p.next = None return res.next 时间复杂度$O(n)$，空间复杂度$O(n)$ Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-06-26 22:47:27 "},"leetcode/2020_06月/6.27缺失的第一个正数.html":{"url":"leetcode/2020_06月/6.27缺失的第一个正数.html","title":"6.27 T41.缺失的第一个正数","keywords":"","body":"6.27 T41.缺失的第一个正数 题目 给你一个未排序的整数数组，请你找出其中没有出现的最小的正整数。 示例 1: 输入: [1,2,0] 输出: 3 示例 2: 输入: [3,4,-1,1] 输出: 2 示例 3: 输入: [7,8,9,11,12] 输出: 1 提示： 你的算法的时间复杂度应为O(n)，并且只能使用常数级别的额外空间。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/first-missing-positive 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解1 题目要求时间复杂度为$O(n)$，空间复杂度$O(1)$，找到最小未出现的正数。 这里可以利用原数组的空间，来达到$O(1)$的空间复杂度。 若数组nums长度为n，则结果为1到n+1。 第一次遍历数组，将非正数和大于n的数变为n+1 第二次遍历数组，a = nums[i]，此时1 ，将nums[a-1]标记为负 第三次遍历数组，找到第一个不是负数的下标i，则返回结果i+1；若全为负数，则返回n+1 核心思想：用数组nums[a]的正负来标记a+1是否出现过。 class Solution: def firstMissingPositive(self, nums: List[int]) -> int: n = len(nums) for i in range(n): if nums[i]n: nums[i] = n+1 for i in range(n): if abs(nums[i])==n+1: continue a = abs(nums[i]) sign = 1 if nums[a-1]0: return i+1 return n+1 题解2 置换 遍历数组，若值1 ，则将其放到正确的位置上，使得nums[a] = a+1 这里加入nums[a-1]!=nums[i]，已经在正确位置不用交换，避免陷入死循环。 例如：[3, 4, -1, 1]变为[1, -1, 3, 4] 然后遍历数组，找到第一个不是正确位置的数的下标i，返回结果i+1 class Solution: def firstMissingPositive(self, nums: List[int]) -> int: n = len(nums) i = 0 while i Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-06-28 20:35:35 "},"leetcode/2020_06月/6.28长度最小的子数组.html":{"url":"leetcode/2020_06月/6.28长度最小的子数组.html","title":"6.28 T209.长度最小的子数组","keywords":"","body":"6.28 T209.长度最小的子数组 题目 给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的连续子数组，并返回其长度。如果不存在符合条件的连续子数组，返回 0。 示例： 输入：s = 7, nums = [2,3,1,2,4,3] 输出：2 解释：子数组 [4,3] 是该条件下的长度最小的连续子数组。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/minimum-size-subarray-sum 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解 一看到连续子数组，且数组值都为正数，就想到递增的前缀和。或者使用滑动窗口 然后使用双指针法 class Solution: def minSubArrayLen(self, s: int, nums: List[int]) -> int: n = len(nums) pre = [0]*(n+1) for i in range(n): pre[i+1] = pre[i] + nums[i] left, right = 0, 1 res = 0 while right 代码编写改进 class Solution: def minSubArrayLen(self, s: int, nums: List[int]) -> int: if not nums: return 0 n = len(nums) ans = n + 1 start, end = 0, 0 total = 0 while end = s: ans = min(ans, end - start + 1) total -= nums[start] start += 1 end += 1 return 0 if ans == n + 1 else ans # 作者：LeetCode-Solution # 链接：https://leetcode-cn.com/problems/minimum-size-subarray-sum/solution/chang-du-zui-xiao-de-zi-shu-zu-by-leetcode-solutio/ # 来源：力扣（LeetCode） # 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-06-28 22:03:00 "},"leetcode/2020_06月/6.29数组中的第K个最大元素.html":{"url":"leetcode/2020_06月/6.29数组中的第K个最大元素.html","title":"6.29 T215.数组中的第K个最大元素","keywords":"","body":"6.29 T215.数组中的第K个最大元素 题目 在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。 示例 1: 输入: [3,2,1,5,6,4] 和 k = 2 输出: 5 示例 2: 输入: [3,2,3,1,2,4,5,5,6] 和 k = 4 输出: 4 说明: 你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/kth-largest-element-in-an-array 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 分析 针对这种求第K大或第K小的数，有两种方法： 借助快排思想，只找到划分后第K个位置的数。选择左递归或右递归 堆排序。找第K大，维护一个大小为K的小顶堆。最后结果就是堆顶 题解1 快排思想 class Solution: def findKthLargest(self, nums: List[int], k: int) -> int: def part(left, right): piv = nums[left] a, b = left, right-1 while a=piv: b -= 1 nums[a], nums[b] = nums[b], nums[a] while an-k: right = a else: left = a+1 a = part(left, right) return nums[a] 时间复杂度$O(n\\log{n})$，空间复杂度$O(n\\log{n})$。leetcode提交1132ms 改进，对每次划分的基准随机取出，据《算法导论》证明时间复杂度为$O(n)$。leetcode提交56ms import random class Solution: def findKthLargest(self, nums: List[int], k: int) -> int: def part(left, right): # 随机取出划分基准 ind = random.randint(left, right-1) nums[left], nums[ind] = nums[ind], nums[left] piv = nums[left] a, b = left, right-1 while a=piv: b -= 1 nums[a] = nums[b] while an-k: right = a else: left = a+1 a = part(left, right) return nums[a] 题解2 小顶堆 class Solution: def findKthLargest(self, nums: List[int], k: int) -> int: \"\"\"使用小顶堆\"\"\" q = [] for c in nums: heapq.heappush(q, c) while len(q) > k: heapq.heappop(q) return heapq.heappop(q) Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-06-29 21:27:46 "},"leetcode/2020_06月/6.30剑指Offer09.用两个栈实现队列.html":{"url":"leetcode/2020_06月/6.30剑指Offer09.用两个栈实现队列.html","title":"6.30 剑指Offer09.用两个栈实现队列","keywords":"","body":"6.30 剑指Offer09.用两个栈实现队列 题目 用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 ) 示例 1： 输入： [\"CQueue\",\"appendTail\",\"deleteHead\",\"deleteHead\"] [[],[3],[],[]] 输出：[null,null,3,-1] 示例 2： 输入： [\"CQueue\",\"deleteHead\",\"appendTail\",\"appendTail\",\"deleteHead\",\"deleteHead\"] [[],[],[5],[2],[],[]] 输出：[null,-1,null,null,5,2] 提示： 1 最多会对 appendTail、deleteHead 进行 10000 次调用 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解 用两个栈模拟队列，一个负责入队，一个负责出队。 入队：stack_append.append(val) 出队：将stack_append中的元素依次退出并压入stack_delete栈中，再返回stack_delete.pop() class CQueue: def __init__(self): self.stack_append = [] self.stack_delete = [] def appendTail(self, value: int) -> None: self.stack_append.append(value) def deleteHead(self) -> int: m, n = len(self.stack_append), len(self.stack_delete) if m==0 and n==0: return -1 if n==0: while self.stack_append: temp = self.stack_append.pop() self.stack_delete.append(temp) return self.stack_delete.pop() # Your CQueue object will be instantiated and called as such: # obj = CQueue() # obj.appendTail(value) # param_2 = obj.deleteHead() Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-06-30 17:03:58 "},"leetcode/2020_07月/":{"url":"leetcode/2020_07月/","title":"7月每题","keywords":"","body":"7月每题 Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-07-01 09:53:37 "},"leetcode/2020_07月/7.01最长重复子数组.html":{"url":"leetcode/2020_07月/7.01最长重复子数组.html","title":"7.01 T718.最长重复子数组","keywords":"","body":"7.01 T718.最长重复子数组 题目 给两个整数数组 A 和 B ，返回两个数组中公共的、长度最长的子数组的长度。 示例 1: 输入: A: [1,2,3,2,1] B: [3,2,1,4,7] 输出: 3 解释: 长度最长的公共子数组是 [3, 2, 1]。 说明: 1 0 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解1 动态规划，dp[i][j]表示以A[i], B[j]开头的的最长公共子数组。 class Solution: def findLength(self, A: List[int], B: List[int]) -> int: m, n = len(A), len(B) dp = [[0]*(n+1) for _ in range(m+1)] res = 0 for i in range(m-1, -1, -1): for j in range(n-1, -1, -1): if A[i]==B[j]: dp[i][j] = dp[i+1][j+1] + 1 res = max(res, dp[i][j]) return res 时间复杂度$O(mn)$，空间复杂度$O(mn)$ 题解2 思路：滑动窗口 m = len(A), n = len(B) 将B在A上滑动，取最长子数组长度。时间复杂度$O(m\\min{m, n})$ 同理将A在B上滑动，时间复杂度$O(n\\min(m, n))$ class Solution: def findLength(self, A: List[int], B: List[int]) -> int: m, n = len(A), len(B) res = 0 for i in range(m): k = 0 for j in range(min(m-i, n)): if A[i+j]==B[j]: k += 1 res = max(res, k) else: k = 0 for i in range(n): k = 0 for j in range(min(n-i, m)): if B[i+j]==A[j]: k += 1 res = max(res, k) else: k = 0 return res 时间复杂度$O((m+n)\\times\\min{(m, n)})$ 题解3 哈希+二分 二分：若A和B的最长子数组长度为K，则必有长度为k(k)的公共子数组。二分查找K 哈希：将A和B的所有长度为k的子数组哈希，每次判断A和B中是否有相同的哈希值 哈希化思路，给定一个质数p，将A[i:i+k]表示成p进制的数 Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-07-01 11:36:15 "},"leetcode/2020_07月/7.02有序矩阵中第K小的元素.html":{"url":"leetcode/2020_07月/7.02有序矩阵中第K小的元素.html","title":"7.02 T378.有序矩阵中第K小的元素","keywords":"","body":"7.02 T378.有序矩阵中第K小的元素 题目 给定一个 n x n 矩阵，其中每行和每列元素均按升序排序，找到矩阵中第 k 小的元素。 请注意，它是排序后的第 k 小元素，而不是第 k 个不同的元素。 示例： matrix = [ [ 1, 5, 9], [10, 11, 13], [12, 13, 15] ], k = 8, 返回 13。 提示： 你可以假设 k 的值永远是有效的，1 ≤ k ≤ n2 。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/kth-smallest-element-in-a-sorted-matrix 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解1 暴力+排序 题中说明：矩阵每行从左至右递增，从上至下递增 思路：对可能的值加入队列，然后排序，取出第k小的数 对于matric[i][j]，小于等于它的数个数为$(i+1)\\times(j+1)$，对应于矩阵左上角区域。 所以对于matrix[i][:]，第k小的数只存在于matrix[i][: k//(i+1)]中。 class Solution: def kthSmallest(self, matrix: List[List[int]], k: int) -> int: li = [] n = len(matrix) for i in range(min(k, n)): for j in range(min(k//(i+1), n)): li.append(matrix[i][j]) li.sort() return li[k-1] 时间复杂度$O(n^2\\log{n})$，空间复杂度$O(n^2)$。leetcode执行时间220ms。 题解2 归并+小顶堆 把每行看成是一个升序列，将问题转化为n个有序数组，求第k小的数。 用归并排序，构建小顶堆，归并k次。 class Heap: # 为题目建立特定的 小顶堆(堆中元素为序列) def __init__(self): self.heap = [] def down(self, ind): n = len(self.heap) while ind*2+1>1) >= 0: par = (ind-1)>>1 if self.heap[par][0]0: self.heap[0], self.heap[-1] = self.heap[-1], self.heap[0] a = self.heap.pop() self.down(0) return a return None class Solution: def kthSmallest(self, matrix: List[List[int]], k: int) -> int: heap = Heap() n = len(matrix) for i in range(n): heap.heappush((matrix[i][0], i, 0)) for i in range(k-1): val, r, c = heap.heappop() if c==n-1: continue heap.heappush((matrix[r][c+1], r, c+1)) return heap.heappop()[0] 时间复杂度$O(k\\log{n})$，空间复杂度$O(n)$。leetcode执行时间640ms。 借助python自带小顶堆模块，leetcode执行时间260ms。 import heapq class Solution: def kthSmallest(self, matrix: List[List[int]], k: int) -> int: n = len(matrix) pq = [(matrix[i][0], i, 0) for i in range(n)] heapq.heapify(pq) for i in range(k - 1): num, x, y = heapq.heappop(pq) if y != n - 1: heapq.heappush(pq, (matrix[x][y + 1], x, y + 1)) return heapq.heappop(pq)[0] 题解3 二分 显然matrix[0][0]是最小值，matrix[n-1][n-1]是最大值，求第k小的值必定在这二者之间，二分。 问题在于如何决定二分的区间？ mid = (matrix[0][0] + matrix[n-1][n-1])>>1，则可在$O(n)$的时间内找到小于等于mid的个数。 从matrix[n-1][0]往右找到第一个大于mid的值 然后再往上找到第一个不大于mid的值，再往右。如此循环，直至找到第一行为止。 参考leetcode题解图： class Solution: def kthSmallest(self, matrix: List[List[int]], k: int) -> int: n = len(matrix) def check(mid): cnt = 0 i, j = n-1, 0 while i>-1 and j>1 if check(mid): left = mid + 1 else: right = mid return right 时间复杂度$O(n\\log(r-l))$，空间复杂度$O(1)$，$l$和$r$分别为矩阵的最小值和最大值。 leetcode提交192ms，超过99%python3用户。 Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-07-02 18:14:22 "},"leetcode/2020_07月/7.03将有序数组转换为二叉搜索树.html":{"url":"leetcode/2020_07月/7.03将有序数组转换为二叉搜索树.html","title":"7.03 T108.将有序数组转换为二叉搜索树","keywords":"","body":"7.03 T108.将有序数组转换为二叉搜索树 题目 将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。 本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。 示例: 给定有序数组: [-10,-3,0,5,9], 一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树： 0 / \\ -3 9 / / -10 5 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解 递归 按照中序遍历，递归转换为平衡二叉搜索数。 # Definition for a binary tree node. # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution: def sortedArrayToBST(self, nums: List[int]) -> TreeNode: def dfs(nums): n = len(nums) if n==0: return None if n==1: return TreeNode(nums[0]) ind = n>>1 root = TreeNode(nums[ind]) root.left = dfs(nums[:ind]) root.right = dfs(nums[ind+1:]) return root return dfs(nums) 时间复杂度$O(n)$，每个节点访问一次 空间复杂度$O(\\log{n})$，栈的递归深度 Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-07-03 10:19:13 "},"leetcode/2020_07月/7.04最长有效括号.html":{"url":"leetcode/2020_07月/7.04最长有效括号.html","title":"7.04 T32.最长有效括号","keywords":"","body":"7.04 T32.最长有效括号 题目 给定一个只包含 '(' 和 ')' 的字符串，找出最长的包含有效括号的子串的长度。 示例 1: 输入: \"(()\" 输出: 2 解释: 最长有效括号子串为 \"()\" 示例 2: 输入: \")()())\" 输出: 4 解释: 最长有效括号子串为 \"()()\" 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/longest-valid-parentheses 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解1 基本想法： 使用栈。括号匹配只有一种情况：栈顶为(，遍历的当前元素为) 目标是求最长的有效子串长度。可利用一个和字符串一样长的辅助数组，记录哪个索引对应字符括号匹配，就令其为1。最后就是计算辅助数组中最长连续1的个数 class Solution: def longestValidParentheses(self, s: str) -> int: n = len(s) res = 0 li = [0]*n stack = [] for i in range(n): if not stack: stack.append(i) continue if s[stack[-1]]=='(' and s[i]==')': a = stack.pop() li[a] = li[i] = 1 else: stack.append(i) cnt = 0 for i in range(n): if li[i]==1: cnt += 1 res = max(res, cnt) else: cnt = 0 return res 时间复杂度$O(n)$，空间复杂度$O(n)$ 题解2 针对题解1的改进。使用栈，栈中元素是字符串对应索引 每次匹配成功，就减去栈顶索引，求出连续匹配成功的子串长度。 class Solution: def longestValidParentheses(self, s: str) -> int: res, n = 0, len(s) stack = [-1, 0] for i in range(1, n): if len(stack)>1 and s[stack[-1]]=='(' and s[i]==')': stack.pop() res = max(res, i-stack[-1]) else: stack.append(i) return res 时间复杂度$O(n)$，空间复杂度$O(n)$ 题解3 遍历字符串，left记录左括号(的个数，right记录右括号的个数。 当right>left时，表明遍历到当前的字符之前的子串，不可能合法。令left=right=0 当left==right时，由于上一步的操作，所以这时为合法串，长度为2*left 因为只有当left==right时，才计算长度。为解决形如((())，所以需从右往左遍历一次。 class Solution: def longestValidParentheses(self, s: str) -> int: def f(s, sign=True): res, left, right = 0, 0, 0 if sign==False: s = s[::-1] for c in s: if c=='(': left += 1 else: right += 1 if left==right: res = max(res, left*2) if sign: if right>left: left, right = 0, 0 else: if left>right: left, right = 0, 0 return res res = f(s, True) res = max(res, f(s, False)) return res 时间复杂度$O(n)$，空间复杂度$O(1)$ Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-07-04 11:13:42 "},"leetcode/2020_07月/7.05通配符匹配.html":{"url":"leetcode/2020_07月/7.05通配符匹配.html","title":"7.05 T44.通配符匹配","keywords":"","body":"7.05 T44.通配符匹配 题目 给定一个字符串 (s) 和一个字符模式 (p) ，实现一个支持 '?' 和 '*' 的通配符匹配。 '?' 可以匹配任何单个字符。 '*' 可以匹配任意字符串（包括空字符串）。 两个字符串完全匹配才算匹配成功。 说明: s 可能为空，且只包含从 a-z 的小写字母。 p 可能为空，且只包含从 a-z 的小写字母，以及字符 ? 和 *。 示例 1:输入: s = \"aa\" p = \"a\" 输出: false 解释: \"a\" 无法匹配 \"aa\" 整个字符串。 示例 2:输入: s = \"aa\" p = \"*\" 输出: true 解释: '*' 可以匹配任意字符串。 示例 3:输入: s = \"cb\" p = \"?a\" 输出: false 解释: '?' 可以匹配 'c', 但第二个 'a' 无法匹配 'b'。 示例 4:输入: s = \"adceb\" p = \"*a*b\" 输出: true 解释: 第一个 '*' 可以匹配空字符串, 第二个 '*' 可以匹配字符串 \"dce\". 示例 5:输入: s = \"acdcb\" p = \"a*c?b\" 输出: false 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/wildcard-matching 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解 动态规划，f[i][j]表示p前i个字符和s的前j个字符是否匹配。 初始状态： f[-1][-1] = True都为空，满足匹配 若s为空，p中只有*号，则也满足匹配 分情况状态转移： 当p[i]=='*'时，选择匹配或不匹配，对应f[i][j] = f[i][j-1] or f[i-1][j] 当p[i] in {s[j], '?'}时，对应f[i][j] = f[i-1][j-1] 除上述两种情况，无法匹配p[i]和s[j]，则f[i][j] = False python3代码如下： class Solution: def isMatch(self, s: str, p: str) -> bool: m, n = len(s), len(p) f = [[False]*(1+n) for _ in range(1+m)] f[-1][-1] = True for i in range(n): if p[i]=='*': f[-1][i] = True else: break for i in range(m): for j in range(n): if p[j] in {\"?\", s[i]}: f[i][j] = f[i-1][j-1] if p[j]=='*': f[i][j] = f[i-1][j] or f[i][j-1] return f[m-1][n-1] 时间复杂度$O(mn)$，空间复杂度$O(mn)$ Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-07-06 08:57:48 "},"leetcode/2020_07月/7.06不同路径II.html":{"url":"leetcode/2020_07月/7.06不同路径II.html","title":"7.06 T63.不同路径II","keywords":"","body":"7.06 T63.不同路径II 题目 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。 现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？ 网格中的障碍物和空位置分别用 1 和 0 来表示。 说明：m 和 n 的值均不超过 100。 示例 1: 输入: [ [0,0,0], [0,1,0], [0,0,0] ] 输出: 2 解释: 3x3 网格的正中间有一个障碍物。 从左上角到右下角一共有 2 条不同的路径： 1. 向右 -> 向右 -> 向下 -> 向下 2. 向下 -> 向下 -> 向右 -> 向右 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/unique-paths-ii 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解 class Solution: def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int: if len(obstacleGrid)==0 or len(obstacleGrid[0])==0: return 0 m, n = len(obstacleGrid), len(obstacleGrid[0]) dp = [[0]*n for _ in range(m)] dp[0][0] = 1 if obstacleGrid[0][0]==0 else 0 for i in range(m): for j in range(n): if i==0 and j==0: continue if obstacleGrid[i][j]==1: dp[i][j] = 0 else: dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[-1][-1] 时间复杂度$O(mn)$，空间复杂度$O(mn)$ 利用滚动数组思想简化辅助空间。观察上述思想dp[i][j]只与dp[i-1][j]和dp[i][j-1]有关，所以我们开辟一个一维数组f = [0]*n，通过更新f，不断记录所需状态。 class Solution: def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int: if len(obstacleGrid)==0 or len(obstacleGrid[0])==0: return 0 m, n = len(obstacleGrid), len(obstacleGrid[0]) f = [0]*n f[0] = 1-obstacleGrid[0][0] # 初始状态 for i in range(m): for j in range(n): if i==0 and j==0: continue if obstacleGrid[i][j]!=1: f[j] = f[j]+f[j-1] if j>0 else f[j] else: f[j] = 0 return f[-1] 时间复杂度$O(mn)$，空间复杂度$O(n)$ Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-07-06 09:16:56 "},"leetcode/2020_07月/7.07路径总和.html":{"url":"leetcode/2020_07月/7.07路径总和.html","title":"7.07 T112.路径总和","keywords":"","body":"7.07 T112.路径总和 题目 给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。 说明: 叶子节点是指没有子节点的节点。 示例: 给定如下二叉树，以及目标和 sum = 22， 5 / \\ 4 8 / / \\ 11 13 4 / \\ \\ 7 2 1 返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5->4->11->2。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/path-sum 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 样例 [5,4,8,11,null,13,4,7,2,null,null,null,1] 22 [] 0 [1,2] 1 # 结果 true false false 题解 递归 # Definition for a binary tree node. # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution: def hasPathSum(self, root: TreeNode, sum: int) -> bool: def dfs(root, target): if not root: return False if not root.left and not root.right: return target==root.val return dfs(root.left, target-root.val) or dfs(root.right, target-root.val) return dfs(root, sum) 时间复杂度$O(n)$，空间复杂度$O(h)$，$h$为树高，最坏情况树退化为链表$h = n$ Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-07-07 10:15:25 "},"leetcode/2020_07月/7.08面试题16.11.跳水板.html":{"url":"leetcode/2020_07月/7.08面试题16.11.跳水板.html","title":"7.08 面试题16.11.跳水板","keywords":"","body":"7.08 面试题16.11.跳水板 题目 你正在使用一堆木板建造跳水板。有两种类型的木板，其中长度较短的木板长度为shorter，长度较长的木板长度为longer。你必须正好使用k块木板。编写一个方法，生成跳水板所有可能的长度。 返回的长度需要从小到大排列。 示例： 输入： shorter = 1 longer = 2 k = 3 输出： {3,4,5,6} 提示： 0 0 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/diving-board-lcci 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解 class Solution: def divingBoard(self, shorter: int, longer: int, k: int) -> List[int]: res = [] if k==0: return res for i in range(k+1): temp = shorter*(k-i)+longer*i if not res or res[-1]!=temp: res.append(temp) return res class Solution: def divingBoard(self, shorter: int, longer: int, k: int) -> List[int]: if k == 0:return [] if shorter == longer: return [k*shorter] return list(range(shorter*k,longer*k+1,(longer-shorter))) Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-07-08 15:03:28 "},"leetcode/2020_07月/7.09面试题17.13.恢复空格.html":{"url":"leetcode/2020_07月/7.09面试题17.13.恢复空格.html","title":"7.09 面试题17.13.恢复空格","keywords":"","body":"7.09 面试题17.13.恢复空格 题目 哦，不！你不小心把一个长篇文章中的空格、标点都删掉了，并且大写也弄成了小写。像句子\"I reset the computer. It still didn’t boot!\"已经变成了\"iresetthecomputeritstilldidntboot\"。在处理标点符号和大小写之前，你得先把它断成词语。当然了，你有一本厚厚的词典dictionary，不过，有些词没在词典里。假设文章用sentence表示，设计一个算法，把文章断开，要求未识别的字符最少，返回未识别的字符数。 注意：本题相对原题稍作改动，只需返回未识别的字符数 示例： 输入： dictionary = [\"looked\",\"just\",\"like\",\"her\",\"brother\"] sentence = \"jesslookedjustliketimherbrother\" 输出： 7 解释： 断句后为\"jess looked just like tim her brother\"，共7个未识别字符。 提示： 0 dictionary中总字符数不超过 150000。 你可以认为dictionary和sentence中只包含小写字母。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/re-space-lcci 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解1 递归 dfs(left)表示sentence[left:]未识别的最少字符数。 递归终点： left == n-1，$n = len(sentence)$，返回sentence[left] not in words 递归过程： 固定left后 遍历range(left+1, n)，相当于添加空格将sentence[left:]分成两部分为sentence[left:i]和sentence[i:] 前一部分当成一个单词，判断是否在词典中；第二部分使用递归求得结果。再将其相加，得到最小的分割方案结果。 class Solution: def respace(self, dictionary: List[str], sentence: str) -> int: n = len(sentence) words = set(dictionary) meno = {} def dfs(left): if left in meno: return meno[left] if left==n-1: return sentence[left:] not in words if sentence[left:] in words: meno[left] = 0 return 0 res = n-left for i in range(left+1, n): a = 0 if sentence[left:i] in words else i-left b = dfs(i) res = min(res, a+b) meno[left] = res return res return dfs(0) leetcode提交1744ms，战胜12%的python3用户。 题解2 动态规划+字典树 基本思路同递归一样。动态规划从字符串尾部向前遍历。dp[i]表示sentence[i:]的最少未必配字符数。 初始化： $ dp[i] = dp[i+1] + 1$ 状态转移： 当sentence[i:j]在词典中，$dp[i] = \\min(dp[i], dp[j]) ,\\quad j \\in {i+1, i+2, ..., n}$ 当第一步j从i+1到n遍历时，若sentence[i:j]不在词典中，就退出j的循环 关于第二点为什么当不在词典中就可以退出j的循环？ 首先考虑计算$dp[i]$，则按照上述流程从$j \\in {i+1, ..., n}$开始往后遍历，直至$sentence[i:j_0]$不在词典中。 则$sentence[i:j_0-1]$在词典中，所以$dp[i] = \\min(dp[i], dp[j_0-1])$，又$dp[j_0-1] = 1 + dp[j_0]$。 倘若不退出j循环，继续进行，则$dp[i] = \\min(dp[i], j-i + dp[j]) ,\\quad for \\ j \\in {j_0, j_0+1, ..., n}$ 由： $dp[i] = \\min(dp[i], dp[j_0-1])$ $dp[j_0-1] = 1+dp[j_0]$ $dp[j_0] \\leq dp[j_0+1] + 1$ 得： $1 \\leq j-i,\\quad for \\ j \\in {j_0, j_0+1, ..., n}$ $dp[j_0-1] \\leq j-i + dp[j] ,\\quad for \\ j \\in {j_0, j_0+1, ..., n}$ from collections import defaultdict from functools import reduce class Solution: def respace(self, dictionary: List[str], sentence: str) -> int: Trie = lambda : defaultdict(Trie) trie = Trie() for word in dictionary: reduce(dict.__getitem__, word, trie)['END'] = True n = len(sentence) f = [n]*(n+1); f[n]=0 for i in range(n-1, -1, -1): temp = trie f[i] = f[i+1] + 1 for j in range(i, n): c = sentence[j] if c in temp: temp = temp[c] if 'END' in temp: f[i] = min(f[i], f[j+1]) else: break # print(f) return f[0] 执行用时：260ms，在所有Python3提交中击败了87.50%的用户。 Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-07-12 16:36:33 "},"leetcode/2020_07月/7.10最佳买卖股票时机含冷冻期.html":{"url":"leetcode/2020_07月/7.10最佳买卖股票时机含冷冻期.html","title":"7.10 T309.最佳买卖股票时机含冷冻期","keywords":"","body":"7.10 T309.最佳买卖股票时机含冷冻期 题目 给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。​ 设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。 示例: 输入: [1,2,3,0,2] 输出: 3 解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出] 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解 动态规划 分情况： f[i][0]，截至第i天，手中有股票 f[i][1]，第i天把手中股票卖出，手中已无股票（意味着，且第i+1天无法购入） f[i][2]，截至第i天，手中无股票，且不是第i天卖出（意味着第i+1天可以购入） 购入，相当于与扣钱；卖出，等于加钱。 状态转移： $f[i][0] = \\max(f[i-1][2] - prices[i], f[i-1][0])$ $f[i][1] = f[i-1][0] + prices[i]$ $f[i][2] = \\max(f[i-1][2], f[i-1][1])$ class Solution: def maxProfit(self, prices: List[int]) -> int: res = 0; n = len(prices) if n==0: return 0 # f[i]表示第i天：有股票；没有股票，当天卖出；没有股票，不是当天卖出 f = [[0]*3 for _ in range(n)] f[0][0] = -prices[0] for i in range(1, n): f[i][0] = max(f[i-1][2] - prices[i], f[i-1][0]) f[i][1] = f[i-1][0] + prices[i] f[i][2] = max(f[i-1][1], f[i-1][2]) return max(f[n-1][1], f[n-1][2]) 时间复杂度$O(n)$，空间复杂度$O(n)$ Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-07-11 18:52:13 "},"leetcode/2020_07月/7.11计算右侧小于当前元素的个数.html":{"url":"leetcode/2020_07月/7.11计算右侧小于当前元素的个数.html","title":"7.11 T315.计算右侧小于当前元素的个数","keywords":"","body":"7.11 T315.计算右侧小于当前元素的个数 题目 给定一个整数数组 nums，按要求返回一个新数组 counts。数组 counts 有该性质： counts[i] 的值是 nums[i] 右侧小于 nums[i] 的元素的数量。 示例: 输入: [5,2,6,1] 输出: [2,1,1,0] 解释: 5 的右侧有 2 个更小的元素 (2 和 1). 2 的右侧仅有 1 个更小的元素 (1). 6 的右侧有 1 个更小的元素 (1). 1 的右侧有 0 个更小的元素. 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解 树状数组（用于频繁查找前k项和，以及更新值） 逆序遍历数组，将数组值作为树状数组的索引，已遍历则树状数组对应索引值加1 class BIT: def __init__(self, n): self.n = n self.tree = [0]*(n+1) def lowbit(self, x): return x&(-x) def update(self, ind, val): while ind0: res += self.tree[ind] ind -= self.lowbit(ind) return res class Solution: def countSmaller(self, nums: List[int]) -> List[int]: n = len(nums) if n==0: return [] MAX, MIN = max(nums), min(nums) bit = BIT(MAX-MIN+1) res = [] for i in range(n-1, -1, -1): ind = nums[i]-MIN+1 res.append(bit.getsum(ind-1)) bit.update(ind, 1) return res[::-1] 时间复杂度$O(n\\log{n})$，空间复杂度$O(MAX-MIN)$，$MAX$和$MIN$为数组最大值和最小值 改进 问题：当数组中值非常大，但长度很小时，树状数组有很多0值。 改进：针对空间优化，对原数组去重排序，再构建桶用于树状数组。每次获取数组值对应桶序号使用二分查找。 class BIT: def __init__(self, n): self.n = n self.tree = [0]*(n+1) def lowbit(self, x): return x&(-x) def update(self, ind, val): while ind0: res += self.tree[ind] ind -= self.lowbit(ind) return res class Solution: def countSmaller(self, nums: List[int]) -> List[int]: if not nums: return [] li = list(set(nums)); li.sort() n = len(li) bit = BIT(n) res = [] def binary_query(val): l, r = 0, n while l>1 if li[mid]val: r = mid else: return mid+1 return l+1 for i in range(len(nums)-1, -1, -1): ind = binary_query(nums[i]) res.append(bit.getsum(ind-1)) bit.update(ind, 1) return res[::-1] 时间复杂度$O(n\\log{n})$，空间复杂度$O(n)$ Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-07-11 19:17:08 "},"leetcode/2020_07月/7.12地下城游戏.html":{"url":"leetcode/2020_07月/7.12地下城游戏.html","title":"7.12 T174.地下城游戏","keywords":"","body":"7.12 T174.地下城游戏 题目 一些恶魔抓住了公主（P）并将她关在了地下城的右下角。地下城是由 M x N 个房间组成的二维网格。我们英勇的骑士（K）最初被安置在左上角的房间里，他必须穿过地下城并通过对抗恶魔来拯救公主。 骑士的初始健康点数为一个正整数。如果他的健康点数在某一时刻降至 0 或以下，他会立即死亡。 有些房间由恶魔守卫，因此骑士在进入这些房间时会失去健康点数（若房间里的值为负整数，则表示骑士将损失健康点数）；其他房间要么是空的（房间里的值为 0），要么包含增加骑士健康点数的魔法球（若房间里的值为正整数，则表示骑士将增加健康点数）。 为了尽快到达公主，骑士决定每次只向右或向下移动一步。 编写一个函数来计算确保骑士能够拯救到公主所需的最低初始健康点数。 例如，考虑到如下布局的地下城，如果骑士遵循最佳路径 右 -> 右 -> 下 -> 下，则骑士的初始健康点数至少为 7。 -2(K) -3 3 -5 -10 1 10 30 -5(P) 说明: 骑士的健康点数没有上限。 任何房间都可能对骑士的健康点数造成威胁，也可能增加骑士的健康点数，包括骑士进入的左上角房间以及公主被监禁的右下角房间。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/dungeon-game 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解1 递归 递归函数中记录当前路径的前缀和su，以及按照当前路径能够到达该点的最小血量res。 class Solution: def calculateMinimumHP(self, dungeon: List[List[int]]) -> int: m, n = len(dungeon), len(dungeon[0]) INF = int(1e9+7) f = [[INF]*n for _ in range(m)] def dfs(x, y, su, res): if x>=m or y>=n: return su += dungeon[x][y] if su leetcode超时。 递归从左上至右下，因为结果受到两个因素的影响，前缀和以及满足当前路径的最小血量。所以当到达的终点相同时，如果路径不一样，则前缀和有可能不一样，对应下一步的最小血量的结果也会不一样，递归造成大量的路径选择，且无法用记忆化。 题解2 动态规划 f[i][j]记录到达第i行第j列时，从右下到左上依次记录骑士所需的最小血量。 class Solution: def calculateMinimumHP(self, dungeon: List[List[int]]) -> int: m, n = len(dungeon), len(dungeon[0]) INF = int(1e9+7) f = [[INF]*(n+1) for _ in range(m+1)] f[m][n-1] = f[m-1][n] = 1 for i in range(m-1, -1, -1): for j in range(n-1, -1, -1): temp = min(f[i+1][j], f[i][j+1]) f[i][j] = max(temp-dungeon[i][j], 1) return f[0][0] 时间复杂度$O(mn)$，空间复杂度$O(mn)$ leetcode提交，76ms，超过14%python3用户。 Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-07-13 09:12:18 "},"leetcode/2020_07月/7.13两个数组的交集II.html":{"url":"leetcode/2020_07月/7.13两个数组的交集II.html","title":"7.13 T350.两个数组的交集II","keywords":"","body":"7.13 T350.两个数组的交集II 题目 给定两个数组，编写一个函数来计算它们的交集。 示例 1: 输入: nums1 = [1,2,2,1], nums2 = [2,2] 输出: [2,2] 示例 2: 输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4] 输出: [4,9] 说明： 输出结果中每个元素出现的次数，应与元素在两个数组中出现的次数一致。我们可以不考虑输出结果的顺序。 进阶: 如果给定的数组已经排好序呢？你将如何优化你的算法？ 如果 nums1 的大小比 nums2 小很多，哪种方法更优？ 如果 nums2 的元素存储在磁盘上，磁盘内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？ 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/intersection-of-two-arrays-ii 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解1 哈希表 import collections class Solution: def intersect(self, nums1: List[int], nums2: List[int]) -> List[int]: A = collections.Counter(nums1) B = collections.Counter(nums2) res = [] for k in A.keys(): if k in B: cnt = min(A[k], B[k]) res.extend(cnt*[k]) return res 题解2 排序后，两个指针分别从列表头往后遍历 class Solution: def intersect(self, nums1: List[int], nums2: List[int]) -> List[int]: nums1.sort(); nums2.sort() a, b = 0, 0 m, n = len(nums1), len(nums2) res = [] while anums2[b]: b += 1 else: res.append(nums1[a]) a += 1; b += 1 return res Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-07-13 09:50:03 "},"leetcode/2020_07月/7.14三角形最小路径和.html":{"url":"leetcode/2020_07月/7.14三角形最小路径和.html","title":"7.14 T120.三角形最小路径和","keywords":"","body":"7.14 T120.三角形最小路径和 题目 给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。 相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。 例如，给定三角形： [ [2], [3,4], [6,5,7], [4,1,8,3] ] 自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。 说明： 如果你可以只使用 O(n) 的额外空间（n 为三角形的总行数）来解决这个问题，那么你的算法会很加分。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/triangle 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解1 递归（超时） class Solution: def minimumTotal(self, triangle: List[List[int]]) -> int: self.res = int(1e9+7) n = len(triangle) if n==0: return 0 def dfs(r, l, pre): if r==n-1: self.res = min(self.res, pre) return dfs(r+1, l, pre + triangle[r+1][l]) dfs(r+1, l+1, pre + triangle[r+1][l+1]) dfs(0, 0, triangle[0][0]) return self.res 题解2 动态规划（自底向上） class Solution: def minimumTotal(self, triangle: List[List[int]]) -> int: n = len(triangle) if n==0: return 0 li = triangle[n-1].copy() for i in range(n-2, -1, -1): for j in range(i+1): li[j] = min(li[j], li[j+1]) + triangle[i][j] return li[0] 时间复杂度$O(n^2)$，空间复杂度$O(n)$ Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-07-14 10:18:36 "},"leetcode/2020_07月/7.15不同的二叉搜索树.html":{"url":"leetcode/2020_07月/7.15不同的二叉搜索树.html","title":"7.15 T96.不同的二叉搜索树","keywords":"","body":"7.15 T96.不同的二叉搜索树 题目 给定一个整数 n，求以 1 ... n 为节点组成的二叉搜索树有多少种？ 示例: 输入: 3 输出: 5 解释: 给定 n = 3, 一共有 5 种不同结构的二叉搜索树: 1 3 3 2 1 \\ / / / \\ \\ 3 2 1 1 3 2 / / \\ \\ 2 1 2 3 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/unique-binary-search-trees 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解1 动态规划 $f[i]$记录i个节点的二叉搜索数种数。则$f[0] = 1; f[1] = 1$，状态转移为 $f[i] = \\sum_{j=0}^{i-1} f[j]*f[i-1-j]$ 对于$i$个节点构成二叉搜索数的种数，根节点占1个节点，左子树$j$个节点构成的种数乘以右子树$i-1-j$个节点构成的种数，$j$从$0$到$i-1$进行累加。 class Solution: def numTrees(self, n: int) -> int: f = [1, 1] for i in range(2, n+1): temp = 0 for j in range(i): temp += f[i-1-j]*f[j] f.append(temp) return f[n] 题解2 数学公式 卡塔兰数$C_n$，卡塔兰数更便于计算的定义如下: $C0 = 1, \\quad C{n+1} = \\frac{2(2n+1)}{n+2}C_n$ 等价形式有： $ \\begin{aligned} \\operatorname{Catalan}(n) &=C{2 n}^{n}-C{2 n}^{n+1} \\ &=\\frac{(2 n) !}{n ! n !}-\\frac{(2 n)!}{(n+1) !(n-1) !} \\ &=\\frac{(2 n) !}{n!\\times \\frac{n+1}{n+1} \\times n(n-1) !}-\\frac{(2 n) !}{(n+1) !(n-1) !} \\ &=\\frac{(2 n) !}{(n+1) ! \\times (n-1) !} \\times \\left(\\frac{n+1}{n}-1\\right) \\ &=\\frac{(2 n) !}{(n+1) n ! \\times (n-1) !} \\times \\frac{1}{n} \\ &=\\frac{(2 n) !}{(n+1) n ! \\times n!} \\ &=\\frac{C_{2 n}^{n}}{n+1} \\end{aligned} $ class Solution(object): def numTrees(self, n): \"\"\" :type n: int :rtype: int \"\"\" C = 1 for i in range(0, n): C = C * 2*(2*i+1)/(i+2) return int(C) # 作者：LeetCode-Solution # 链接：https://leetcode-cn.com/problems/unique-binary-search-trees/solution/bu-tong-de-er-cha-sou-suo-shu-by-leetcode-solution/ # 来源：力扣（LeetCode） # 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-07-15 11:20:20 "},"leetcode/2020_07月/7.16判断二分图.html":{"url":"leetcode/2020_07月/7.16判断二分图.html","title":"7.16 T785.判断二分图","keywords":"","body":"7.16 T785.判断二分图 题目 给定一个无向图graph，当这个图为二分图时返回true。 如果我们能将一个图的节点集合分割成两个独立的子集A和B，并使图中的每一条边的两个节点一个来自A集合，一个来自B集合，我们就将这个图称为二分图。 graph将会以邻接表方式给出，graph[i]表示图中与节点i相连的所有节点。每个节点都是一个在0到graph.length-1之间的整数。这图中没有自环和平行边： graph[i] 中不存在i，并且graph[i]中没有重复的值。 示例 1: 输入: [[1,3], [0,2], [1,3], [0,2]] 输出: true 解释: 无向图如下: 0----1 | | | | 3----2 我们可以将节点分成两组: {0, 2} 和 {1, 3}。 示例 2: 输入: [[1,2,3], [0,2], [0,1,3], [0,2]] 输出: false 解释: 无向图如下: 0----1 | \\ | | \\ | 3----2 我们不能将节点分割成两个独立的子集。 注意: graph 的长度范围为 [1, 100]。 graph[i] 中的元素的范围为 [0, graph.length - 1]。 graph[i] 不会包含 i 或者有重复的值。 图是无向的: 如果j 在 graph[i]里边, 那么 i 也会在 graph[j]里边。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/is-graph-bipartite 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解1 广度优先遍历，模拟点涂色过程 任选一起始点涂成A色，并开始广搜 若当前点为A色，则广搜下一邻接节点必须为B色（若该邻接节点已涂色，且为A则返回False） import collections class Solution: def isBipartite(self, graph: List[List[int]]) -> bool: n = len(graph) A, B = set(), set() queue = collections.deque() visited = set() # 图中可能有多个连通子图，所以需要遍历起始点 for start in range(n): if start in visited: continue # 由start为起点广搜该连通子图 queue.append(start) A.add(start); visited.add(start) flag = True; cnt = 1 while queue: t = queue.popleft() cnt -= 1 for i in graph[t]: if flag: if i in A: return False B.add(i) else: if i in B: return False A.add(i) if i not in visited: queue.append(i) visited.add(i) if cnt==0: flag = not flag cnt = len(queue) return True 直接使用一个列表存储对应节点的颜色 class Solution: def isBipartite(self, graph: List[List[int]]) -> bool: n = len(graph) UNCOLORED, RED, GREEN = 0, 1, 2 color = [UNCOLORED] * n for i in range(n): if color[i] == UNCOLORED: q = collections.deque([i]) color[i] = RED while q: node = q.popleft() cNei = (GREEN if color[node] == RED else RED) for neighbor in graph[node]: if color[neighbor] == UNCOLORED: q.append(neighbor) color[neighbor] = cNei elif color[neighbor] != cNei: return False return True # 作者：LeetCode-Solution # 链接：https://leetcode-cn.com/problems/is-graph-bipartite/solution/pan-duan-er-fen-tu-by-leetcode-solution/ # 来源：力扣（LeetCode） # 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 时间复杂度$O(m+n)$ 题解2 深度优先遍历 class Solution: def isBipartite(self, graph: List[List[int]]) -> bool: n = len(graph) colors = [0]*n def dfs(ind, c): if colors[ind]!=0: return colors[ind] == c colors[ind] = c nc = 1 if c==2 else 2 for i in graph[ind]: if not dfs(i, nc): return False return True for i in range(n): if colors[i]==0 and not dfs(i, 1): return False return True 题解3 并查集 将同一节点A的邻接点全部并到一个集合中，若A与邻接点在同一集合中，则返回False class Union: def __init__(self, n): self.parent = [i for i in range(n)] def find(self, ind): if self.parent[ind]==ind: return ind self.parent[ind] = self.find(self.parent[ind]) return self.parent[ind] def union(self, ind1, ind2): self.parent[self.find(ind1)] = self.find(ind2) class Solution: def isBipartite(self, graph: List[List[int]]) -> bool: n = len(graph) UN = Union(n) for i in range(n): for j in graph[i]: if UN.find(i)==UN.find(j): return False UN.union(graph[i][0], j) return True 时间复杂度$O(n+m)$ Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-07-16 17:14:15 "},"leetcode/2020_07月/7.17搜索插入位置.html":{"url":"leetcode/2020_07月/7.17搜索插入位置.html","title":"7.17 T35.搜索插入位置","keywords":"","body":"7.17 T35.搜索插入位置 题目 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。 你可以假设数组中无重复元素。 示例 1: 输入: [1,3,5,6], 5 输出: 2 示例 2: 输入: [1,3,5,6], 2 输出: 1 示例 3: 输入: [1,3,5,6], 7 输出: 4 示例 4: 输入: [1,3,5,6], 0 输出: 0 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/search-insert-position 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解 二分查找 注意： 每次取中点$mid$，可按照$mid = ((right-left)>>1) + left$防止计算$left+right$溢出。 切记：mid = left + ((right-left)>>1)记住要加括号 两种策略。 第一种：含左不含右，即$[left, right)$， 循环条件是$left 若$target>nums[mid]$，则在$mid$的右边找$[mid+1, right)$，令$left = mid+1$ 若$target 若$target==nums[mid]$，则找到返回$mid$下标 结束循环后，$left==right$，最后返回$left$ python代码如下： class Solution: def searchInsert(self, nums: List[int], target: int) -> int: n = len(nums) left, right = 0, n while left>1 if nums[mid]>target: right = mid elif nums[mid] 第二种：含左含右，即$[left, right]$ 循环条件是$left 若$target 若$target>nums[mid]$，取右边$[mid+1, right]$，令$left = mid+1$ 若$target==nums[mid]$，返回结果索引$mid$ 结束循环后，$right=left-1$，$nums[right] python代码如下： class Solution: def searchInsert(self, nums: List[int], target: int) -> int: n = len(nums) left, right = 0, n-1 while left>1 if nums[mid]>target: right = mid - 1 elif nums[mid] 时间复杂度$O(\\log(n))$ Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-07-22 18:20:33 "},"leetcode/2020_07月/7.18交错字符串.html":{"url":"leetcode/2020_07月/7.18交错字符串.html","title":"7.18 T97.交错字符串","keywords":"","body":"7.18 T97.交错字符串 题目 给定三个字符串 s1, s2, s3, 验证 s3 是否是由 s1 和 s2 交错组成的。 示例 1: 输入: s1 = \"aabcc\", s2 = \"dbbca\", s3 = \"aadbbcbcac\" 输出: true 示例 2: 输入: s1 = \"aabcc\", s2 = \"dbbca\", s3 = \"aadbbbaccc\" 输出: false 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/interleaving-string 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解 动态规划 初级：$f[i][j][k]$表示s3前i个字符，s1前j个字符，s2前k个字符，能否交错。 如果f[i][j][k]==True，则 if j if k class Solution: def isInterleave(self, s1: str, s2: str, s3: str) -> bool: m, n = len(s1), len(s2) if len(s3)!=m+n: return False if m==0 and n==0: return True if m==0: return s2==s3 if n==0: return s1==s3 f = [[[False]*(n+1) for i in range(m+1)] for j in range(n+m+1)] if m>0 and s3[0]==s1[0]: f[1][1][0] = True if n>0 and s3[0]==s2[0]: f[1][0][1] = True for i in range(1, n+m): l, r = max(0, i-n), min(i, m)+1 for j in range(l, r): k = i-j if f[i][j][k]: if j 观察发现$i = j+k$。时间复杂度$O((m+n)n)$，空间复杂度$O((m+n)mn)$ 改进状态表示 由上面分析，len(s3) = len(s1) + len(s2)，所以$f[i][j]$表示s1前i个字符，s2前j个字符，能否交错形成s3前i+j个字符。 class Solution: def isInterleave(self, s1: str, s2: str, s3: str) -> bool: m, n = len(s1), len(s2) if len(s3)!=m+n: return False f = [[False]*(n+1) for _ in range(m+1)] f[0][0] = True for i in range(m+1): for j in range(n+1): if i==0 and j==0: continue f[i][j] = (f[i-1][j] and s1[i-1]==s3[i-1+j]) or (f[i][j-1] and s2[j-1]==s3[i+j-1]) return f[m][n] 时间复杂度$O(mn)$，空间复杂度$O(mn)$ 改进空间复杂度 使用滚动数组，复用状态，优化空间复杂度。 观察$f[i][j]$方法，每次更新状态时，将状态看作矩阵形式时，只于左边和上边状态有关。 class Solution: def isInterleave(self, s1: str, s2: str, s3: str) -> bool: m, n = len(s1), len(s2) if len(s3)!=m+n: return False f = [False]*(n+1) f[0] = True for i in range(m+1): for j in range(n+1): # 因为要用到自身，所以先判断矩阵中上面状态的转移 if i>0: f[j] &= (s1[i-1]==s3[i+j-1]) # 再判断左边状态转移，得到最终状态 if j>0: f[j] |= (f[j-1] and s2[j-1]==s3[i+j-1]) return f[n] 时间复杂度$O(mn)$，空间复杂度$O(n)$ Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-07-18 14:48:29 "},"leetcode/2020_07月/7.19戳气球.html":{"url":"leetcode/2020_07月/7.19戳气球.html","title":"7.19 T312.戳气球","keywords":"","body":"7.19 T312.戳气球 题目 有 n 个气球，编号为0 到 n-1，每个气球上都标有一个数字，这些数字存在数组 nums 中。 现在要求你戳破所有的气球。如果你戳破气球 i ，就可以获得 nums[left] nums[i] nums[right] 个硬币。 这里的 left 和 right 代表和 i 相邻的两个气球的序号。注意当你戳破了气球 i 后，气球 left 和气球 right 就变成了相邻的气球。 求所能获得硬币的最大数量。 说明: 你可以假设 nums[-1] = nums[n] = 1，但注意它们不是真实存在的所以并不能被戳破。 0 ≤ n ≤ 500, 0 ≤ nums[i] ≤ 100 示例: 输入: [3,1,5,8] 输出: 167 解释: nums = [3,1,5,8] --> [3,5,8] --> [3,8] --> [8] --> [] coins = 3*1*5 + 3*5*8 + 1*3*8 + 1*8*1 = 167 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/burst-balloons 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解1 递归+记忆化 反向思考，初始左右各添加一个值为1的辅助气球，方便讨论边界。 看作将气球一个个添加至辅助气球中间，操作和戳气球相反，但硬币结果是一样的。 记$dfs(l, r)$为索引开区间$(l, r)$的最大硬币数，则 $dfs(l, r) = \\max_{mid=l+1}^{r-1} (nums[l]nums[mid]nums[r] + dfs(l, mid) + dfs(mid, r))$ class Solution: def maxCoins(self, nums: List[int]) -> int: nums.insert(0, 1) nums.append(1) n = len(nums) meno = {} def dfs(l, r): if (l, r) in meno: return meno[(l, r)] if r 时间复杂度$O(n^3)$，空间复杂度$O(n^2)$。 题解2 动态规划 基本思路同递归一样。 注意：动态规划状态遍历的顺序 因为状态转移要用到f[i][k]和f[k][j]，其中i。 所以第一维必须从大到小遍历，否则因为k>i，此时f[k][j]还未跟新状态，不是最终正确结果。 第二维必须从小到大遍历，否则因为k，此时f[i][k]还未跟新状态。 class Solution: def maxCoins(self, nums: List[int]) -> int: ums.insert(0, 1) nums.append(1) n = len(nums) f = [[0]*n for _ in range(n)] # OK for i in range(n-1, -1, -1): for j in range(i+1, n): for k in range(i+1, j): f[i][j] = max(f[i][j], nums[i]*nums[k]*nums[j] + f[i][k] + f[k][j]) return f[0][n-1] Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-07-19 17:02:21 "},"leetcode/2020_07月/7.20两数之和II-输入有序数组.html":{"url":"leetcode/2020_07月/7.20两数之和II-输入有序数组.html","title":"7.20 T167.两数之和II-输入有序数组","keywords":"","body":"7.20 T167.两数之和II-输入有序数组 题目 给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。 函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。 说明: 返回的下标值（index1 和 index2）不是从零开始的。 你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。 示例: 输入: numbers = [2, 7, 11, 15], target = 9 输出: [1,2] 解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解 哈希表 class Solution: def twoSum(self, numbers: List[int], target: int) -> List[int]: vised = {} n = len(numbers) for i in range(n): num = numbers[i] if target-num in vised: return [vised[target-num], i+1] vised[num] = i+1 时间复杂度$O(n)$，空间复杂度$O(n)$ Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-07-21 12:08:23 "},"leetcode/2020_07月/7.21不同的二叉搜索树II.html":{"url":"leetcode/2020_07月/7.21不同的二叉搜索树II.html","title":"7.21 T95.不同的二叉搜索树II","keywords":"","body":"7.21 T95.不同的二叉搜索树II 题目 给定一个整数 n，生成所有由 1 ... n 为节点所组成的二叉搜索树。 示例： 输入：3 输出： [ [1,null,3,2], [3,2,null,1], [3,1,null,null,2], [2,1,3], [1,null,2,null,3] ] 解释： 以上的输出对应以下 5 种不同结构的二叉搜索树： 1 3 3 2 1 \\ / / / \\ \\ 3 2 1 1 3 2 / / \\ \\ 2 1 2 3 提示： 0 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/unique-binary-search-trees-ii 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解 递归 $dfs(lo, hi)$返回节点值为$lo, lo+1, ..., hi-1, hi$的所有二叉搜索树。 # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def generateTrees(self, n: int) -> List[TreeNode]: if n==0: return [] meno = {} def dfs(lo, hi): if (lo, hi) in meno: return meno[(lo, hi)] if lo>hi: return [None] if lo==hi: return [TreeNode(lo)] li = [] for i in range(lo, hi+1): lchilds = dfs(lo, i-1) rchilds = dfs(i+1, hi) for l in lchilds: for r in rchilds: node = TreeNode(i) node.left = l node.right = r li.append(node) meno[(lo, hi)] = li return li return dfs(1, n) 复杂度分析： 时间复杂度：整个算法的时间复杂度取决于「可行二叉搜索树的个数」，而对于$n$个点生成的二叉搜索树数量等价于数学上第$n$个「卡特兰数」，用$G_n$表示。卡特兰数具体的细节请读者自行查询，这里不再赘述，只给出结论。生成一棵二叉搜索树需要$O(n)$的时间复杂度，一共有$G_n$棵二叉搜索树，也就是$O(nG_n)$。而卡特兰数以$\\frac{4^n}{n^{3/2}}$增长，因此总时间复杂度为$O(\\frac{4^n}{n^{1/2}})$。 空间复杂度：$n$个点生成的二叉搜索树有$G_n$棵，每棵有$n$个节点，因此存储的空间需要$O(nG_n) = O(\\frac{4^n}{n^{1/2}})$，递归函数需要$O(n)$的栈空间，因此总空间复杂度为$O(\\frac{4^n}{n^{1/2}})$。 作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/unique-binary-search-trees-ii/solution/bu-tong-de-er-cha-sou-suo-shu-ii-by-leetcode-solut/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-07-21 12:18:34 "},"leetcode/2020_07月/7.22剑指Offer11.旋转数组的最小数字.html":{"url":"leetcode/2020_07月/7.22剑指Offer11.旋转数组的最小数字.html","title":"7.22 剑指Offer11.旋转数组的最小数字","keywords":"","body":"7.22 剑指Offer11.旋转数组的最小数字 题目 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。 示例 1： 输入：[3,4,5,1,2] 输出：1 示例 2： 输入：[2,2,2,0,1] 输出：0 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解 二分搜索 leetcode官方题解写的舒服一些，贴上来。 class Solution: def minArray(self, numbers: List[int]) -> int: low, high = 0, len(numbers) - 1 while low numbers[high]: low = pivot + 1 else: high -= 1 return numbers[low] # 作者：LeetCode-Solution # 链接：https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/solution/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-by-leetcode-s/ # 来源：力扣（LeetCode） # 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-07-22 18:23:14 "},"leetcode/2020_07月/7.23最小路径和.html":{"url":"leetcode/2020_07月/7.23最小路径和.html","title":"7.23 T64.最小路径和","keywords":"","body":"7.23 T64.最小路径和 题目 给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。 说明：每次只能向下或者向右移动一步。 示例: 输入: [ [1,3,1], [1,5,1], [4,2,1] ] 输出: 7 解释: 因为路径 1→3→1→1→1 的总和最小。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/minimum-path-sum 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解 动态规划 + 空间优化 class Solution: def minPathSum(self, grid: List[List[int]]) -> int: m, n = len(grid), len(grid[0]) if m==0 or n==0: return 0 INF = int(1e9+7) f = [INF]*n f[0] = grid[0][0] for i in range(m): for j in range(n): if i>0 and j>0: f[j] = min(f[j], f[j-1]) + grid[i][j] elif i>0: f[j] = f[j] + grid[i][j] elif j>0: f[j] = f[j-1] + grid[i][j] return f[-1] 时间复杂度$O(mn)$，空间复杂度$O(n)$ Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-07-23 15:40:28 "},"leetcode/2020_07月/7.24除数博弈.html":{"url":"leetcode/2020_07月/7.24除数博弈.html","title":"7.24 T1025.除数博弈","keywords":"","body":"7.24 T1025.除数博弈 题目 爱丽丝和鲍勃一起玩游戏，他们轮流行动。爱丽丝先手开局。 最初，黑板上有一个数字 N 。在每个玩家的回合，玩家需要执行以下操作： 选出任一 x，满足 0 用 N - x 替换黑板上的数字 N 。 如果玩家无法执行这些操作，就会输掉游戏。 只有在爱丽丝在游戏中取得胜利时才返回 True，否则返回 false。假设两个玩家都以最佳状态参与游戏。 示例 1： 输入：2 输出：true 解释：爱丽丝选择 1，鲍勃无法进行操作。 示例 2： 输入：3 输出：false 解释：爱丽丝选择 1，鲍勃也选择 1，然后爱丽丝无法进行操作。 提示： 1 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/divisor-game 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解1 动态规划 $f[i]$表示初始数为$i$，先手输赢。 import math class Solution: def divisorGame(self, N: int) -> bool: f = [False]*(N+1) if N==1: return False f[2] = True for i in range(3, N+1): for j in range(1, int(math.sqrt(i)) + 1): if i%j==0: if f[i-j]==False: f[i] = True break if j!=1 and f[i- i//j]==False: f[i] = True break return f[N] 时间复杂度$O(n^2)$，空间复杂度$O(n)$。 题解2 观察，发现$f[1]=False;\\ f[2]=True;\\ f[3]=False;\\ f[4]=True;\\ ...$ 1是任何数的因数，所以通过观察我们不妨假设$f[2\\times i]=True;\\ f[2\\times i+1]=False$ 数学归纳法证明： 当$k \\in {1,\\ 2}$时，$f[1]=False;\\ f[2]=True$。 当$k=2\\times i$时，因为1是因数，所以$k$减去1，因为$k-1$为奇数，$f[k-1]=False$，所以$f[k]=True$。 同理当$k=2\\times i + 1$时，奇数的因数肯定是奇数，所以奇数减去奇数之后为偶数，则$f[k-x]=True$，所以$f[k]=False$。 class Solution: def divisorGame(self, N: int) -> bool: return N&1==0 Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-07-24 15:35:01 "},"leetcode/2020_07月/7.25分割数组的最大值.html":{"url":"leetcode/2020_07月/7.25分割数组的最大值.html","title":"7.25 T410.分割数组的最大值","keywords":"","body":"7.25 T410.分割数组的最大值 题目 给定一个非负整数数组和一个整数 m，你需要将这个数组分成 m 个非空的连续子数组。设计一个算法使得这 m 个子数组各自和的最大值最小。 注意:数组长度 n 满足以下条件: 1 ≤ n ≤ 1000 1 ≤ m ≤ min(50, n) 示例: ``` 输入: nums = [7,2,5,10,8] m = 2 输出: 18 解释: 一共有四种方法将nums分割为2个子数组。 其中最好的方式是将其分为[7,2,5] 和 [10,8]， 因为此时这两个子数组各自的和的最大值为18，在所有情况中最小。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/split-array-largest-sum 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 ## 题解1 动态规划 题目意思是针对每一个数组，都有一个划分，在确定划分后，求得每个连续子数组和，再取这个划分下所有连续子数组和的最大值。然后，针对每一个划分，都有一个数组和的最大值，最后结果就是这一系列数的最小值。 为方便理解，用符号标记说明。 - 假设数组为 $nums$ ，将其划分为 $m$ 个连续子数组，设它满足条件的划分方案数有 $K$ 种。 对于第 $i$ 种划分方案，将数组 $nums$ 划分为 $m$ 个连续子数组 $arr_{i_1}, arr_{i_2}, ..., arr_{i_m}$， 得到最大连续数组和为 $a_i = \\max_{j=1}^m (sum(arr_{i_j}))$。 则最终答案为 \\[ res = \\min_{i=1}^K a_i \\] 接下来使用动态规划解决，设`f[i][j]`为将数组`nums[:i+1]`划分为`j`个连续子数组的结果。则最终结果为`f[n-1][m]; n = len(nums)` 状态转移：$f[i][j] = \\min_{k=j-2}^{i-1}( \\max(f[k][j-1], sum(nums[k+1:i+1])\\ )\\ )$ ![](../../assert/picture_blog/7.25T410分割数组的最大值.png) 从`j-2`到`i-1`枚举`k`，将`[0, k]`范围的数组划分为`j-1`组，将`[k+1, i]`划分为一组，得到该划分情况下和的最大值，再取所有情况的最小值即为`f[i][j]`。 python3代码： ```python class Solution: def splitArray(self, nums: List[int], m: int) -> int: n = len(nums) if m>=n: return max(nums) # 建立前缀数组，方便求连续子数组和 pre = [0]*n for i in range(n): pre[i] = pre[i-1] + nums[i] INF = 1时间复杂度$O(n^2 m)$，空间复杂度$O(mn)$。 题解2 二分 题目目标是，找到所有满足要求的划分情况中的最大连续子数组和的最小值。 贪心模拟划分情况，在区间[max(nums), sum(nums)]中二分查找连续子数组和的最大值。若在该值下，数组划分为连续子数组个数大于m时，说明该值偏小，在右区间查找；若个数小于m，则说明该值偏大，在左区间查找。 class Solution: def splitArray(self, nums: List[int], m: int) -> int: # 模拟数组划分，当最大子数组和不超过x时，返回可以划分的子数组个数 def split_arr(x): cnt = 1; pre = 0 for v in nums: if pre + v > x: cnt += 1 pre = v else: pre += v return cnt left, right = max(nums), sum(nums) while left>1) + left temp = split_arr(mid) if temp 时间复杂度$O(n \\ \\log{(sum(nums)-\\max(nums))}\\ )$ Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-07-25 10:32:55 "},"leetcode/2020_07月/7.26矩阵中的最长递增路径.html":{"url":"leetcode/2020_07月/7.26矩阵中的最长递增路径.html","title":"7.26 T329.矩阵中的最长递增路径","keywords":"","body":"7.26 T329.矩阵中的最长递增路径 题目 给定一个整数矩阵，找出最长递增路径的长度。 对于每个单元格，你可以往上，下，左，右四个方向移动。 你不能在对角线方向上移动或移动到边界外（即不允许环绕）。 示例 1: 输入: nums = [ [9,9,4], [6,6,8], [2,1,1] ] 输出: 4 解释: 最长递增路径为 [1, 2, 6, 9]。 示例 2: 输入: nums = [ [3,4,5], [3,2,6], [2,2,1] ] 输出: 4 解释: 最长递增路径是 [3, 4, 5, 6]。注意不允许在对角线方向上移动。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/longest-increasing-path-in-a-matrix 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解 递归 题目难点在于：下一步可以是上下左右移动 可将矩阵看作一个有向图，矩阵每个元素作为节点的值，节点到其上下左右节点之间存在有向边（节点值小的指向节点值大的）。题目要求就是找到最长路径上的节点数。 用一个哈希表记录从(x, y)节点出发的最长路径节点数，减少冗余搜索。 class Solution: def longestIncreasingPath(self, matrix: List[List[int]]) -> int: if len(matrix)==0 or len(matrix[0])==0: return 0 m, n = len(matrix), len(matrix[0]) direc = {(0, 1), (1, 0), (0, -1), (-1, 0)} meno = dict() # 从matrix[x][y]出发递增的最大路径长度 def dfs(x, y): if (x, y) in meno: return meno[(x, y)] res = 1 for a, b in direc: xt, yt = x + a, y + b if 0matrix[x][y]: res = max(res, dfs(xt, yt)+1) meno[(x, y)] = res return res res = -1 for x in range(m): for y in range(n): res = max(res, dfs(x, y, set([(x, y)]))) # print(res, x, y) return res 时间复杂度$O(mn)$，有向图中每个节点搜索了一次。 空间复杂度$O(mn)$，递归深度和哈希表的大小。 Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-07-28 10:41:05 "},"leetcode/2020_07月/7.27判断子序列.html":{"url":"leetcode/2020_07月/7.27判断子序列.html","title":"7.27 T392.判断子序列","keywords":"","body":"7.27 T392.判断子序列 题目 给定字符串 s 和 t ，判断 s 是否为 t 的子序列。 你可以认为 s 和 t 中仅包含英文小写字母。字符串 t 可能会很长（长度 ~= 500,000），而 s 是个短字符串（长度 字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，\"ace\"是\"abcde\"的一个子序列，而\"aec\"不是）。 示例 1: s = \"abc\", t = \"ahbgdc\" 返回 true. 示例 2: s = \"axc\", t = \"ahbgdc\" 返回 false. 后续挑战 : 如果有大量输入的 S，称作S1, S2, ... , Sk 其中 k >= 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？ 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/is-subsequence 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解1 双指针 贪心法，从前往后配对。 class Solution: def isSubsequence(self, s: str, t: str) -> bool: m, n = len(s), len(t) if m==0: return True if n==0: return m==0 p, q = 0, 0 while p 时间复杂度$O(m+n)$，空间复杂度$O(1)$ 题解2 对双指针的改进 观察题解1，主要工作花在一步一步的移动字符串t的指针。可以先利用动态规划预处理一下，记录下一步直接匹配的索引。 f[i][j]记录在字符串t中，从索引i往后，第一个字符为j的索引。 class Solution: def isSubsequence(self, s: str, t: str) -> bool: m, n = len(s), len(t) f = [[n]*26 for _ in range(n+1)] for i in range(n-1, -1, -1): for j in range(26): if ord(t[i])-97==j: f[i][j] = i else: f[i][j] = f[i+1][j] p, q = 0, 0 while p 时间复杂度$O(26\\times n + m)$，空间复杂度$O(26\\times n)$ Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-07-27 20:34:08 "},"leetcode/2020_07月/7.28二叉树的最大深度.html":{"url":"leetcode/2020_07月/7.28二叉树的最大深度.html","title":"7.28 T104.二叉树的最大深度","keywords":"","body":"7.28 T104.二叉树的最大深度 题目 给定一个二叉树，找出其最大深度。 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。 说明: 叶子节点是指没有子节点的节点。 示例： 给定二叉树 [3,9,20,null,null,15,7]， 3 / \\ 9 20 / \\ 15 7 返回它的最大深度 3 。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/maximum-depth-of-binary-tree 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解 递归 # Definition for a binary tree node. # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution: def maxDepth(self, root: TreeNode) -> int: def dfs(root): if not root: return 0 return max(dfs(root.left), dfs(root.right))+1 return dfs(root) 时间复杂度$O(n)$，$n$为树的节点个数，每个节点都遍历了一次。 空间复杂度$O(height)$，递归深度为树的高度，最坏情况下树退化为链表，为$O(n)$。 Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-07-28 10:43:49 "},"leetcode/2020_07月/7.29LCP13寻宝.html":{"url":"leetcode/2020_07月/7.29LCP13寻宝.html","title":"7.29 LCP13.寻宝","keywords":"","body":"7.29 LCP13.寻宝 题目 我们得到了一副藏宝图，藏宝图显示，在一个迷宫中存在着未被世人发现的宝藏。 迷宫是一个二维矩阵，用一个字符串数组表示。它标识了唯一的入口（用 'S' 表示），和唯一的宝藏地点（用 'T' 表示）。但是，宝藏被一些隐蔽的机关保护了起来。在地图上有若干个机关点（用 'M' 表示），只有所有机关均被触发，才可以拿到宝藏。 要保持机关的触发，需要把一个重石放在上面。迷宫中有若干个石堆（用 'O' 表示），每个石堆都有无限个足够触发机关的重石。但是由于石头太重，我们一次只能搬一个石头到指定地点。 迷宫中同样有一些墙壁（用 '#' 表示），我们不能走入墙壁。剩余的都是可随意通行的点（用 '.' 表示）。石堆、机关、起点和终点（无论是否能拿到宝藏）也是可以通行的。 我们每步可以选择向上/向下/向左/向右移动一格，并且不能移出迷宫。搬起石头和放下石头不算步数。那么，从起点开始，我们最少需要多少步才能最后拿到宝藏呢？如果无法拿到宝藏，返回 -1 。 示例 1： 输入： [\"S#O\", \"M..\", \"M.T\"] 输出：16 解释：最优路线为： S->O, cost = 4, 去搬石头 O->第二行的M, cost = 3, M机关触发 第二行的M->O, cost = 3, 我们需要继续回去 O 搬石头。 O->第三行的M, cost = 4, 此时所有机关均触发 第三行的M->T, cost = 2，去T点拿宝藏。 总步数为16。 示例 2： 输入： [\"S#O\", \"M.#\", \"M.T\"] 输出：-1 解释：我们无法搬到石头触发机关 示例 3： 输入： [\"S#O\", \"M.T\", \"M..\"] 输出：17 解释：注意终点也是可以通行的。 限制： 1 1 maze[i].length == maze[j].length S 和 T 有且只有一个 0 0 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/xun-bao 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-07-29 18:15:16 "},"leetcode/2020_07月/7.30整数拆分.html":{"url":"leetcode/2020_07月/7.30整数拆分.html","title":"7.30 T343.整数拆分","keywords":"","body":"7.30 T343.整数拆分 题目 给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。 示例 1: 输入: 2 输出: 1 解释: 2 = 1 + 1, 1 × 1 = 1。 示例 2: 输入: 10 输出: 36 解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。 说明: 你可以假设 n 不小于 2 且不大于 58。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/integer-break 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解1 把一个数分为k个正整数，若使其乘积最大，则平分该数为k份。 枚举k，使用快速幂计算。 class Solution: def integerBreak(self, n: int) -> int: res = 1 def mpow(x, a): res = 1 pre = x while a>0: if a&1: res *= pre pre *= pre a >>= 1 return res # 枚举划分份数 for i in range(2, n): a, b = n//i, n%i temp = mpow(a, i-b) * mpow(a+1, b) res = max(res, temp) return res 时间复杂度$O(n\\log{n})$，枚举为$O(n)$，快速幂为$O(\\log{n})$ 空间复杂度$O(1)$ 题解2 动态规划 设f[i][j是将数字i划分为j份的乘积最大值，则状态转移为：枚举一个数字，将剩余数划分为k-1份。 $f[i][j] = \\max_{a=1}^{i-j+1}(f[i-a][j-1] \\times a)$ class Solution: def integerBreak(self, n: int) -> int: f = [[1]*(n+1) for _ in range(n+1)] for i in range(1, n+1): for j in range(1, i+1): for a in range(1, i-j+2): f[i][j] = max(f[i][j], f[i-a][j-1]*a) res = 1 for j in range(2, n+1): res = max(res, f[n][j]) return res 时间复杂度$O(n^3)$，空间复杂度$O(n^2)$ 对上述动态规划进行改进，设f[i]为将数字i划分为至少2份的最大乘积。则初始状态$f[0]=f[1]=f[2]=1$ 状态转移：$f[i] = \\max_{j=1}^{i-1}(f[i-j] \\times j, (i-j)\\times j)$ 枚举最后划分的数字$j$，取划分大于2份，与划分为2份的最大值。 class Solution: def integerBreak(self, n: int) -> int: f = [1]*(n+1) for i in range(1, n+1): for j in range(1, i): f[i] = max(f[i], f[i-j]*j, (i-j)*j) return f[n] 时间复杂度$O(n^2)$，空间复杂度$O(n)$ 题解3 数学推导 class Solution: def integerBreak(self, n: int) -> int: if n Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-07-30 10:49:24 "},"leetcode/2020_08月/":{"url":"leetcode/2020_08月/","title":"8月每题","keywords":"","body":"8月每题 Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-08-04 09:05:47 "},"leetcode/2020_08月/8.01最小区间.html":{"url":"leetcode/2020_08月/8.01最小区间.html","title":"8.01 T632.最小区间","keywords":"","body":"8.01 T632.最小区间 题目 你有 k 个升序排列的整数数组。找到一个最小区间，使得 k 个列表中的每个列表至少有一个数包含在其中。 我们定义如果 b-a 示例 1: 输入:[[4,10,15,24,26], [0,9,12,20], [5,18,22,30]] 输出: [20,24] 解释: 列表 1：[4, 10, 15, 24, 26]，24 在区间 [20,24] 中。 列表 2：[0, 9, 12, 20]，20 在区间 [20,24] 中。 列表 3：[5, 18, 22, 30]，22 在区间 [20,24] 中。 注意: 给定的列表可能包含重复元素，所以在这里升序表示 >= 。 1 $-10^5$ 对于使用Java的用户，请注意传入类型已修改为List>。重置代码模板后可以看到这项改动。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/smallest-range-covering-elements-from-k-lists 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解 问题等价于：从每个列表中选一个数，则共k个数，求k个数的最大值与最小值的差的最大值。 建立小顶堆，每次退堆顶，将退出的对应列表的下一个值加入堆中，并跟新堆中最大值和结果。 import heapq class Solution: def smallestRange(self, nums: List[List[int]]) -> List[int]: res = None k = len(nums) inds = [0]*k heap = [(nums[i][0], i) for i in range(k)] heapq.heapify(heap) mx = max([i[0] for i in heap]) while True: val, ind = heapq.heappop(heap) a = inds[ind] if res==None: res = [val, mx] elif mx-valmx: mx = nums[ind][a+1] inds[ind] += 1 return res 时间复杂度：$O(nk \\log k)$，其中 $n$ 是所有列表的平均长度，$k$ 是列表数量。所有的指针移动的总次数最多是 $nk$ 次，每次从堆中取出元素和添加元素都需要更新堆，时间复杂度是 $O(\\log k)$，因此总时间复杂度是 $O(nk \\log k)$。 空间复杂度：$O(k)$，其中 $k$ 是列表数量。空间复杂度取决于堆的大小，堆中维护 $k$ 个元素。 Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-08-04 10:01:43 "},"leetcode/2020_08月/8.02二叉树展开为链表.html":{"url":"leetcode/2020_08月/8.02二叉树展开为链表.html","title":"8.02 T114.二叉树展开为链表","keywords":"","body":"8.02 T114.二叉树展开为链表 题目 给定一个二叉树，原地将它展开为一个单链表。 例如，给定二叉树 1 / \\ 2 5 / \\ \\ 3 4 6 将其展开为： 1 \\ 2 \\ 3 \\ 4 \\ 5 \\ 6 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解 # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def flatten(self, root: TreeNode) -> None: \"\"\" Do not return anything, modify root in-place instead. \"\"\" def dfs(root): if not root: return dfs(root.left) dfs(root.right) if root.left: tail = root.left while tail.right: tail = tail.right temp = root.right root.right = root.left root.left = None tail.right = temp dfs(root) Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-08-04 09:34:35 "},"leetcode/2020_08月/8.03字符串相加.html":{"url":"leetcode/2020_08月/8.03字符串相加.html","title":"8.03 T415.字符串相加","keywords":"","body":"8.03 T415.字符串相加 题目 给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和。 提示： num1 和num2 的长度都小于 5100 num1 和num2 都只包含数字 0-9 num1 和num2 都不包含任何前导零 你不能使用任何內建 BigInteger 库， 也不能直接将输入的字符串转换为整数形式 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/add-strings 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解 class Solution: def addStrings(self, num1: str, num2: str) -> str: res = '' m, n = len(num1), len(num2) if n>m: num1, num2 = num2, num1 m, n = n, m i, j = m-1, n-1 temp = 0 while i>-1 or j>-1: if i>=0 and j>=0: a = int(num1[i]) + int(num2[j]) + temp i -= 1; j -= 1 else: a = int(num1[i]) + temp i -= 1 res = str(a%10) + res temp = 0 if a0: res = '1' + res # ind = 0 # while ind Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-08-04 09:32:18 "},"leetcode/2020_08月/8.04课程表.html":{"url":"leetcode/2020_08月/8.04课程表.html","title":"8.04 T207.课程表","keywords":"","body":"8.04 T207.课程表 题目 你这个学期必须选修 numCourse 门课程，记为 0 到 numCourse-1 。 在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们：[0,1] 给定课程总量以及它们的先决条件，请你判断是否可能完成所有课程的学习？ 示例 1: 输入: 2, [[1,0]] 输出: true 解释: 总共有 2 门课程。学习课程 1 之前，你需要完成课程 0。所以这是可能的。 示例 2: 输入: 2, [[1,0],[0,1]] 输出: false 解释: 总共有 2 门课程。学习课程 1 之前，你需要先完成​课程 0；并且学习课程 0 之前，你还应先完成课程 1。这是不可能的。 提示: 输入的先决条件是由 边缘列表 表示的图形，而不是 邻接矩阵 。详情请参见图的表示法。 你可以假定输入的先决条件中没有重复的边。 1 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/course-schedule 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解1 广搜 利用拓扑排序，判断是否有环 import collections class Solution: def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool: visited = [0]*numCourses graph = [[] for _ in range(numCourses)] indegree = [0]*numCourses for a, b in prerequisites: graph[a].append(b) indegree[b] += 1 queue = collections.deque([i for i in range(numCourses) if indegree[i]==0]) cnt = 0 while queue: a = queue.popleft() cnt += 1 for i in graph[a]: indegree[i] -= 1 if indegree[i]==0: queue.append(i) return cnt==numCourses 时间复杂度$O(m+n)$，空间复杂度$O(n)$。$n$是点的个数，$m$是边数即先修课程要求数。 题解2 深搜 visited[i]记录节点i的状态 0为未访问 1为在递归路径中，但还未返回 2为已成功返回，压入栈中 栈记录了拓扑排序 class Solution: def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool: visited = [0]*numCourses graph = [[] for _ in range(numCourses)] stack = [] for a, b in prerequisites: graph[a].append(b) def dfs(num): nonlocal visited visited[num] = 1 for i in graph[num]: if visited[i]==0: dfs(i) for i in graph[num]: if visited[i]!=2: break else: stack.append(num) visited[num] = 2 for i in range(numCourses): if visited[i]==0: dfs(i) return len(stack)==numCourses 时间复杂度$O(m+n)$，空间复杂度$O(n)$。$n$是点的个数，$m$是边数即先修课程要求数。 class Solution: def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool: edges = collections.defaultdict(list) visited = [0] * numCourses result = list() valid = True for info in prerequisites: edges[info[1]].append(info[0]) def dfs(u: int): nonlocal valid visited[u] = 1 for v in edges[u]: if visited[v] == 0: dfs(v) if not valid: return elif visited[v] == 1: valid = False return visited[u] = 2 result.append(u) for i in range(numCourses): if valid and not visited[i]: dfs(i) return valid # 作者：LeetCode-Solution # 链接：https://leetcode-cn.com/problems/course-schedule/solution/ke-cheng-biao-by-leetcode-solution/ # 来源：力扣（LeetCode） # 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-08-04 09:55:12 "},"leetcode/2020_08月/8.05打家劫舍III.html":{"url":"leetcode/2020_08月/8.05打家劫舍III.html","title":"8.05 T337.打家劫舍III","keywords":"","body":"8.05 T337.打家劫舍III 题目 在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。 计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。 示例 1: 输入: [3,2,3,null,3,null,1] 3 / \\ 2 3 \\ \\ 3 1 输出: 7 解释: 小偷一晚能够盗取的最高金额 = 3 + 3 + 1 = 7. 示例 2: 输入: [3,4,5,1,3,null,1] 3 / \\ 4 5 / \\ \\ 1 3 1 输出: 9 解释: 小偷一晚能够盗取的最高金额 = 4 + 5 = 9. 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/house-robber-iii 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解 dfs递归 # Definition for a binary tree node. # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution: def rob(self, root: TreeNode) -> int: def dfs(root): if not root: return (0, 0) left = dfs(root.left) right = dfs(root.right) a = max(left[0], left[1]) + max(right[0], right[1]) # 不偷root b = left[0] + right[0] + root.val # 偷root return (a, b) a, b = dfs(root) return max(a, b) 时间复杂度$O(n)$，空间复杂度$O(n)$。 Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-08-05 08:53:17 "},"leetcode/2020_08月/8.06回文对.html":{"url":"leetcode/2020_08月/8.06回文对.html","title":"8.06 T336.回文对","keywords":"","body":"8.06 T336.回文对 题目 给定一组 互不相同 的单词， 找出所有不同 的索引对(i, j)，使得列表中的两个单词， words[i] + words[j] ，可拼接成回文串。 示例 1： 输入：[\"abcd\",\"dcba\",\"lls\",\"s\",\"sssll\"] 输出：[[0,1],[1,0],[3,2],[2,4]] 解释：可拼接成的回文串为 [\"dcbaabcd\",\"abcddcba\",\"slls\",\"llssssll\"] 示例 2： 输入：[\"bat\",\"tab\",\"cat\"] 输出：[[0,1],[1,0]] 解释：可拼接成的回文串为 [\"battab\",\"tabbat\"] 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/palindrome-pairs 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解 还需理解 class Node: def __init__(self): self.ch = [0] * 26 self.flag = -1 class Solution: def palindromePairs(self, words: List[str]) -> List[List[int]]: tree = [Node()] def insert(s: str, index: int): length = len(s) add = 0 for i in range(length): x = ord(s[i]) - ord(\"a\") if tree[add].ch[x] == 0: tree.append(Node()) tree[add].ch[x] = len(tree) - 1 add = tree[add].ch[x] tree[add].flag = index def findWord(s: str, left: int, right: int) -> int: add = 0 for i in range(right, left - 1, -1): x = ord(s[i]) - ord(\"a\") if tree[add].ch[x] == 0: return -1 add = tree[add].ch[x] return tree[add].flag def isPalindrome(s: str, left: int, right: int) -> bool: length = right - left + 1 return length Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-08-11 16:41:46 "},"leetcode/2020_08月/8.07相同的树.html":{"url":"leetcode/2020_08月/8.07相同的树.html","title":"8.07 T100.相同的树","keywords":"","body":"8.07 T100.相同的树 题目 给定两个二叉树，编写一个函数来检验它们是否相同。 如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。 示例 1: 输入: 1 1 / \\ / \\ 2 3 2 3 [1,2,3], [1,2,3] 输出: true 示例 2: 输入: 1 1 / \\ 2 2 [1,2], [1,null,2] 输出: false 示例 3: 输入: 1 1 / \\ / \\ 2 1 1 2 [1,2,1], [1,1,2] 输出: false 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/same-tree 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解 深度优先遍历，同时对两棵树同方向遍历。 # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def isSameTree(self, p: TreeNode, q: TreeNode) -> bool: def dfs(root1, root2): if not root1 and not root2: return True if not root1: return False if not root2: return False if root1.val != root2.val: return False return dfs(root1.left, root2.left) and dfs(root1.right, root2.right) return dfs(p, q) Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-08-11 16:43:06 "},"leetcode/2020_08月/8.08恢复二叉搜索树.html":{"url":"leetcode/2020_08月/8.08恢复二叉搜索树.html","title":"8.08 T99.恢复二叉搜索树","keywords":"","body":"8.08 T99.恢复二叉搜索树 题目 二叉搜索树中的两个节点被错误地交换。 请在不改变其结构的情况下，恢复这棵树。 示例 1: 输入: [1,3,null,null,2] 1 / 3 \\ 2 输出: [3,1,null,null,2] 3 / 1 \\ 2 示例 2: 输入: [3,1,4,null,null,2] 3 / \\ 1 4 / 2 输出: [2,1,4,null,null,3] 2 / \\ 1 4 / 3 进阶: 使用 O(n) 空间复杂度的解法很容易实现。 你能想出一个只使用常数空间的解决方案吗？ 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/recover-binary-search-tree 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解 没注意题目是只交换了一对节点。我的方法适用于交换任意多节点的情况： 对原树遍历，存储所有节点值，并排序。 对原树进行中序遍历，并重新对节点赋值。 # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def recoverTree(self, root: TreeNode) -> None: \"\"\" Do not return anything, modify root in-place instead. \"\"\" def dfs(root): nonlocal nums if not root: return else: nums.append(root.val) dfs(root.left) dfs(root.right) nums = [] dfs(root) nums.sort() ind = 0 stack = [] p = root while stack or p: if p: stack.append(p) p = p.left else: p = stack.pop() p.val = nums[ind] ind += 1 p = p.right 因为排序，时间复杂度$O(n\\log{n})$ 空间复杂度$O(n)$ Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-08-11 16:46:42 "},"leetcode/2020_08月/8.09复原IP地址.html":{"url":"leetcode/2020_08月/8.09复原IP地址.html","title":"8.09 T93.复原IP地址","keywords":"","body":"8.09 T93.复原IP地址 题目 给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。 有效的 IP 地址正好由四个整数（每个整数位于 0 到 255 之间组成），整数之间用 '.' 分隔。 示例: 输入: \"25525511135\" 输出: [\"255.255.11.135\", \"255.255.111.35\"] 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/restore-ip-addresses 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解 递归将s合法分成4份，组成IP地址。 class Solution: def restoreIpAddresses(self, s: str) -> List[str]: n = len(s) def dfs(left, num): if num==1: d = s[left:] if int(d)>255 or (n-left>1 and s[left]=='0'): return [] return [[d]] if n-left > 3*num or n-left 255 or (i-left>1 and s[left]=='0'): break temp = dfs(i, num-1) for j in temp: p = [a] p.extend(j) res.append(p) return res li = dfs(0, 4) res = [] for i in li: res.append('.'.join(i)) return res Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-08-11 16:48:03 "},"leetcode/2020_08月/8.10计数二进制子串.html":{"url":"leetcode/2020_08月/8.10计数二进制子串.html","title":"8.10 T696.计数二进制子串","keywords":"","body":"8.10 T696.计数二进制子串 题目 给定一个字符串 s，计算具有相同数量0和1的非空(连续)子字符串的数量，并且这些子字符串中的所有0和所有1都是组合在一起的。 重复出现的子串要计算它们出现的次数。 示例 1 : 输入: \"00110011\" 输出: 6 解释: 有6个子串具有相同数量的连续1和0：“0011”，“01”，“1100”，“10”，“0011” 和 “01”。 请注意，一些重复出现的子串要计算它们出现的次数。 另外，“00110011”不是有效的子串，因为所有的0（和1）没有组合在一起。 示例 2 : 输入: \"10101\" 输出: 4 解释: 有4个子串：“10”，“01”，“10”，“01”，它们具有相同数量的连续1和0。 注意： s.length 在1到50,000之间。 s 只包含“0”或“1”字符。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/count-binary-substrings 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解 找到连续0或1的个数，暂存进数组。 遍历数组，每相邻的两个数的最小值，表示该连续字符可组成的合法字符的个数。 class Solution: def countBinarySubstrings(self, s: str) -> int: n = len(s) if n==0: return 0 li = [] ch, cnt = s[0], 0 for i in range(n): if s[i]==ch: cnt += 1 else: li.append(cnt) ch = s[i]; cnt = 1 if cnt!=0: li.append(cnt) res = 0 for i in range(len(li)-1): res += min(li[i], li[i+1]) return res Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-08-11 16:50:46 "},"leetcode/2020_08月/8.11被围绕的区域.html":{"url":"leetcode/2020_08月/8.11被围绕的区域.html","title":"8.11 T130.被围绕的区域","keywords":"","body":"8.11 T130.被围绕的区域 题目 给定一个二维的矩阵，包含 'X' 和 'O'（字母 O）。 找到所有被 'X' 围绕的区域，并将这些区域里所有的 'O' 用 'X' 填充。 示例: X X X X X O O X X X O X X O X X 运行你的函数后，矩阵变为： X X X X X X X X X X X X X O X X 解释: 被围绕的区间不会存在于边界上，换句话说，任何边界上的 'O' 都不会被填充为 'X'。 任何不在边界上，或不与边界上的 'O' 相连的 'O' 最终都会被填充为 'X'。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/surrounded-regions 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解 反向思考，只要找到所有不能被包围的'O'记录下来，再遍历矩阵，对不在记录的'O'变为'X'即可。 不能被包围的'O'肯定会和边界的'O'相连通。 对边界上的'O'进行深度优先遍历，记录所有相连的'O'。 遍历矩阵，对不在记录的'O'变为'X'。 class Solution: def solve(self, board: List[List[str]]) -> None: \"\"\" Do not return anything, modify board in-place instead. \"\"\" if not board: return m, n = len(board), len(board[0]) visited = [[0]*n for _ in range(m)] DIREC = [(0, 1), (1, 0), (0, -1), (-1, 0)] def dfs(x, y): visited[x][y] = 1 for x0, y0 in DIREC: a = x + x0 b = y + y0 if 0 Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-08-11 16:54:05 "},"leetcode/2020_08月/8.12克隆图.html":{"url":"leetcode/2020_08月/8.12克隆图.html","title":"8.12 T133.克隆图","keywords":"","body":"8.12 T133.克隆图 题目 给你无向 连通 图中一个节点的引用，请你返回该图的 深拷贝（克隆）。 图中的每个节点都包含它的值 val（int） 和其邻居的列表（list[Node]）。 测试用例格式： 简单起见，每个节点的值都和它的索引相同。例如，第一个节点值为 1（val = 1），第二个节点值为 2（val = 2），以此类推。该图在测试用例中使用邻接列表表示。 邻接列表 是用于表示有限图的无序列表的集合。每个列表都描述了图中节点的邻居集。 给定节点将始终是图中的第一个节点（值为 1）。你必须将 给定节点的拷贝 作为对克隆图的引用返回。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/clone-graph 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解 深度优先遍历 \"\"\" # Definition for a Node. class Node: def __init__(self, val = 0, neighbors = []): self.val = val self.neighbors = neighbors \"\"\" import collections class Solution: def cloneGraph(self, node: 'Node') -> 'Node': if not node: return None visited = dict() res = Node(node.val) visited[node.val] = res graph = collections.defaultdict(set) def dfs(node, newnode): nonlocal visited for i in node.neighbors: nt = Node(i.val) if i.val not in visited else visited[i.val] if i.val not in graph[node.val]: newnode.neighbors.append(nt) nt.neighbors.append(newnode) graph[node.val].add(i.val) graph[i.val].add(node.val) if i.val not in visited: visited[nt.val] = nt dfs(i, nt) dfs(node, res) return res \"\"\" # Definition for a Node. class Node: def __init__(self, val = 0, neighbors = []): self.val = val self.neighbors = neighbors \"\"\" class Solution: def cloneGraph(self, node: 'Node') -> 'Node': visited = {} def dfs(node): nonlocal visited if not node: return node if node.val in visited: return visited[node.val] newnode = Node(node.val) visited[newnode.val] = newnode if node.neighbors: newnode.neighbors = [dfs(i) for i in node.neighbors] return newnode return dfs(node) Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-08-12 11:34:34 "},"杂记/":{"url":"杂记/","title":"杂记","keywords":"","body":"杂记 Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-04-02 11:45:07 "},"杂记/树状数组.html":{"url":"杂记/树状数组.html","title":"树状数组","keywords":"","body":"树状数组 应用背景: 给定一个数组nums, 频繁计算前k项的和, 以及更改nums[i]的值 参考https://www.cnblogs.com/findview/archive/2019/08/01/11281628.html 代码 # python class BIT: ### 注意: 数组下标是从1开始 def __init__(self, n): self.n = n self.tree = [0]*(n+1) def lowbit(self, x: int): # x的二进制末尾连续0的个数为k, 返回2**k # x&(x^(x-1)) return x&(-x) def get_sum(self, k): # 求下标为 10: res += self.tree[k] k -= self.lowbit(k) return res def update_value(self, k, value): # nums[k] += value while k 更新值时间复杂度$O(\\logn)$，查找范围和$O(\\logn)$。 例： 10个数的数组对应的tree数组为: tree_index num_index 0 0000 1 0001 1 2 0010 1 2 3 0011 3 4 0100 1 2 3 4 5 0101 5 6 0110 5 6 7 0111 7 8 1000 1 2 3 4 5 6 7 8 9 1001 9 10 1010 9 10 原理 充分利用下标二进制，更新和查找使用相反的方式，循环次数不会超过$O(\\logn)$。 Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2022-04-05 12:28:21 "},"杂记/python技巧记录.html":{"url":"杂记/python技巧记录.html","title":"python技巧记录","keywords":"","body":"python技巧记录 [toc] 基本语法 语法 条件判断 循环 语法，空格决定逻辑层次关系，行末尾无分号;。 若单行太长，当不在一个括号中时，使用\\续接下一行。 条件判断if else 循环for和while 注意for循环之后，i并没有被销毁。 for可以和else搭配。当for循环中没有break跳出，则执行完for之后会执行else中代码。 常用数据结构 list dict set collections.deque() collections.defaultdict() collections.Counter() list 列表加法、乘法。 乘法要注意列表中存储的数据类型是否是可变类型，如果是可变类型，列表乘法相当于复制该对象的引用，若改变其中一个，其余都会受到影响。 观察，b和a都是存储了列表[1, 2]的引用，所以改变一个，其他的都会改变。 内置常用方法 索引 list.append()和list.pop() list.extend() list.sort()和sorted(list) 索引支持负数从列表尾为-1，依次往前-2， -3…… 切片list[left:right:step]，包含左端点，不包含右端点，每隔step取一个，构成一个新列表。 list.append()和list.pop()都是类似栈，对栈尾添加和删除元素。append()无返回值，pop()返回退出列表的元素。 因为python中list数据结构内部实现类似数组，所以list.remove(), list.pop(0)，都要移动后面的元素，时间复杂度为 $O(n)$ 较高，用的少。 list1.extend(list2)用于合并两个数组，将list2合并至list1，改变了list1，无返回值。 list.sort()对列表进行排序，是稳定的，会改变列表，无返回值。 可通过设置key来决定排序参考基准，下例是使用数组长度来排序，通常使用方法key = lambda x: ... sorted(list)和list.sort()基本一样，但sorted(list)不会改变待排序列表，而是返回一个已排好序的副本列表。 构建多维列表 例如二维：[[0]*n for _ in range(m)]m行n列。 Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2020-05-17 23:14:03 "},"杂记/二进制数枚举子集方法.html":{"url":"杂记/二进制数枚举子集方法.html","title":"二进制枚举子集方法","keywords":"","body":"二进制枚举子集方法 对一个二进制数枚举所有子集 例：数$5_{10} = (101)_2$，有子集${(101)_2, (100)_2, (001)_2, (000)_2}$ 方法一 直接遍历每一位数是否为1 def get_subset(num: int): -> list res = [] k = 0; temp = num ones = [] while temp>0: if temp & 1: ones.append(k) temp >>= 1 k += 1 for i in range(1>j)&1: a += (1 方法二 伪码如下，得到bitmask的二进制数，对应为1位数的所有子集 function get_subset(bitmask) subset = bitmask answer = [bitmask] while subset != 0 subset = (subset - 1) & bitmask put subset into the answer list end while return answer end function 来源：力扣（LeetCode）作者：LeetCode-Solution链接 # python 版本 def get_subset(num): -> list answer = [num] subset = num while subset != 0: subset = (sebset-1) & num answer.append(subset) return answer 解：设$num$的二进制位为1的位数数组为$[1{x_k}, 1{x{k-1}}, ..., 1{x_0}]$ 例如$num=20=(10100)_2$，则1的位数数组为$[1_4, 1_2]$，索引从右往左 从0开始记。 $subset-1$每次则是将$subset$的最后一位的1变为0，往后都变为1。所以对while循环分析，每次经过$subset = (sebset-1) \\& num$的改变 $subset$初始1位数数组为$[1{x_k}, 1{x{k-1}}, ..., 1{x0}]$ 1位数数组为$[1{xk}, 1{x{k-1}}, ..., 1{x1}, 0{x_0}]$ 前：$[1{x_k}, 1{x{k-1}}, ..., 1{x1}, 0{x0}]$ 后：$[1{xk}, 1{x{k-1}}, ..., 0{x1}, 1{x_0}]$ ... 依次类推（可用数学归纳法证明，当$k=1$时，初始情况只有两个1位，经过while循环依次得到$(11)2, (10)_2, (01)_2, (00)_2$；若当$k=i$时，通过while循环也依次得到从大到小的所有1位数形成的子集；则当$k=i+1$时，前一部分同$k=i$一样（无法改变$1{i+1}$的值），后一部分则变为$0_{i+1}$，其余操作一样。），可以得到$num$的所有1位数子集。 Copyright © CodeWAC 2020 all right reserved，powered by Gitbook修订时间： 2021-03-03 10:37:33 "}}